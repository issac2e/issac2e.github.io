<!DOCTYPE html><html lang="zh_CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>io字典 | 每天进步一点点</title><meta name="author" content="issac"><meta name="copyright" content="issac"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="io内容均转载自微信公众号：yes的练级攻略 一、io模型 socket介绍 为啥会阻塞1、为什么网络 I&amp;#x2F;O 会被阻塞？最近打算输出 Netty 相关的文章，但要深入学习 Netty 这个底层通信框架，网络相关知识点不可或缺。所以我打算先写一些前置知识点，对齐一下认识，便于之后对 Net"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://issac2e.github.io/2023/01/20/io/io%E5%AD%97%E5%85%B8/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'io字典',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-02-08 14:42:43'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">7</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/./img/preview5.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="每天进步一点点"><span class="site-name">每天进步一点点</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">io字典</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-01-20T21:36:08.000Z" title="Created 2023-01-20 21:36:08">2023-01-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-02-08T14:42:43.039Z" title="Updated 2023-02-08 14:42:43">2023-02-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/io/">io</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="io字典"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><strong><font color="#0000dd">io内容均转载自微信公众号：yes的练级攻略</font></strong></p>
<h1 id="一、io模型-socket介绍-为啥会阻塞"><a href="#一、io模型-socket介绍-为啥会阻塞" class="headerlink" title="一、io模型 socket介绍 为啥会阻塞"></a>一、io模型 socket介绍 为啥会阻塞</h1><h2 id="1、为什么网络-I-x2F-O-会被阻塞？"><a href="#1、为什么网络-I-x2F-O-会被阻塞？" class="headerlink" title="1、为什么网络 I&#x2F;O 会被阻塞？"></a>1、为什么网络 I&#x2F;O 会被阻塞？</h2><p>最近打算输出 Netty 相关的文章，但要深入学习 Netty 这个底层通信框架，网络相关知识点不可或缺。所以我打算先写一些前置知识点，对齐一下认识，便于之后对 Netty 的理解。</p>
<p>我们应该都知道 socket（套接字），你可以认为我们的通信都要基于这个玩意，而常说的网络通信又分为 TCP 与 UDP 两种，下面我会以 TCP 通信为例来阐述下 socket 的通信流程。</p>
<p>不过在此之前，我先来说说什么叫 I&#x2F;O。</p>
<h2 id="2、I-x2F-O到底是什么"><a href="#2、I-x2F-O到底是什么" class="headerlink" title="2、I&#x2F;O到底是什么?"></a>2、I&#x2F;O到底是什么?</h2><p>I&#x2F;O 其实就是 input 和 output 的缩写，即输入&#x2F;输出。</p>
<p>那输入输出啥呢？</p>
<p>比如我们用键盘来敲代码其实就是输入，那显示器显示图案就是输出，这其实就是 I&#x2F;O。</p>
<p>而我们时常关心的磁盘 I&#x2F;O 指的是硬盘和内存之间的输入输出。</p>
<p>读取本地文件的时候，要将磁盘的数据拷贝到内存中，修改本地文件的时候，需要把修改后的数据拷贝到磁盘中。</p>
<p>网络 I&#x2F;O 指的是网卡与内存之间的输入输出。</p>
<p>当网络上的数据到来时，网卡需要将数据拷贝到内存中。当要发送数据给网络上的其他人时，需要将数据从内存拷贝到网卡里。</p>
<h4 id="那为什么都要跟内存交互呢"><a href="#那为什么都要跟内存交互呢" class="headerlink" title="那为什么都要跟内存交互呢?"></a>那为什么都要跟内存交互呢?</h4><p>我们的指令最终是由 CPU 执行的，究其原因是 CPU 与内存交互的速度远高于 CPU 和这些外部设备直接交互的速度。</p>
<p>因此都是和内存交互，当然假设没有内存，让 CPU 直接和外部设备交互，那也算 I&#x2F;O。</p>
<p>总结下：I&#x2F;O 就是指内存与外部设备之间的交互（数据拷贝）。</p>
<p>好了，明确什么是 I&#x2F;O 之后，让我们来揭一揭 socket 通信内幕~</p>
<h2 id="3、创建-socket"><a href="#3、创建-socket" class="headerlink" title="3、创建 socket"></a>3、创建 socket</h2><p>首先服务端需要先创建一个 socket。在 Linux 中一切都是文件，那么创建的 socket 也是文件，每个文件都有一个整型的文件描述符（fd）来指代这个文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>domain：这个参数用于选择通信的协议族，比如选择 IPv4 通信，还是 IPv6 通信等等</p>
</li>
<li><p>type：选择套接字类型，可选字节流套接字、数据报套接字等等。</p>
</li>
<li><p>protocol：指定使用的协议。</p>
</li>
</ul>
<p>这个 protocol 通常可以设为 0 ，因为由前面两个参数可以推断出所要使用的协议。</p>
<p>比如socket(AF_INET, SOCK_STREAM, 0);，表明使用 IPv4 ，且使用字节流套接字，可以判断使用的协议为 TCP 协议。</p>
<p>这个方法的返回值为 int ，其实就是创建的 socket 的 fd（一个整形的文件描述符）。</p>
<h2 id="4、bind"><a href="#4、bind" class="headerlink" title="4、bind"></a>4、bind</h2><p>现在我们已经创建了一个 socket，但现在还没有地址指向这个 socket。</p>
<p>众所周知，服务器应用需要指明 IP 和端口，这样客户端才好找上门来要服务，所以此时我们需要指定一个地址和端口来与这个 socket 绑定一下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span><br></pre></td></tr></table></figure>

<p>参数里的 sockfd 就是我们创建的 socket 的文件描述符，执行了 bind 参数之后我们的 socket 距离可以被访问又更近了一步。</p>
<h2 id="5、listen"><a href="#5、listen" class="headerlink" title="5、listen"></a>5、listen</h2><p>执行了 socket、bind 之后，此时的 socket 还处于 closed 的状态，也就是不对外监听的，然后我们需要调用 listen 方法，让 socket 进入被动监听状态，这样的 socket 才能够监听到客户端的连接请求。</p>
<p>int listen(int sockfd, int backlog);</p>
<p>传入创建的 socket 的 fd，并且指明一下 backlog 的大小。</p>
<p>这个 backlog 我查阅资料的时候，看到了三种解释：</p>
<p>socket 有一个队列，同时存放已完成的连接和半连接，backlog为这个队列的大小。</p>
<p>socket 有两个队列，分别为已完成的连接队列和半连接队列，backlog为这个两个队列的大小之和。</p>
<p>socket 有两个队列，分别为已完成的连接队列和半连接队列，backlog仅为已完成的连接队列大小。</p>
<h4 id="解释下什么叫半连接"><a href="#解释下什么叫半连接" class="headerlink" title="解释下什么叫半连接"></a>解释下什么叫半连接</h4><p>我们都知道 TCP 建立连接需要三次握手，当接收方收到请求方的建连请求后会返回 ack，此时这个连接在接收方就处于半连接状态，当接收方再收到请求方的 ack 时，这个连接就处于已完成状态：</p>
<img src="/images/WEBRESOURCEa9d936e4192bbe74ae326f249d7652f4.png" style="zoom:50%;" />

<p>所以上面讨论的就是这两种状态的连接的存放问题。</p>
<p>我查阅资料看到，基于 BSD 派生的系统的实现是使用的一个队列来同时存放这两种状态的连接， backlog 参数即为这个队列的大小。</p>
<p>而 Linux 则使用两个队列分别存储已完成连接和半连接，且 backlog 仅为已完成连接的队列大小</p>
<h2 id="6、accept"><a href="#6、accept" class="headerlink" title="6、accept"></a>6、accept</h2><p>现在我们已经初始化好监听套接字了，此时会有客户端连上来，然后我们需要处理这些已经完成建连的连接。</p>
<p>从上面的分析我们可以得知，三次握手完成后的连接会被加入到已完成连接队列中去。</p>
<img src="/images/WEBRESOURCEa25549ad999a3d0e3a1776e5716c4899.png" style="zoom:50%;" />

<p>这时候，我们就需要从已完成连接队列中拿到连接进行处理，这个拿取动作就由 accpet 来完成。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</span><br></pre></td></tr></table></figure>

<p>这个方法返回的 int 值就是拿到的已完成连接的 socket 的文件描述符，之后操作这个 socket 就可以进行通信了。</p>
<p>如果已完成连接队列没有连接可以取，那么调用 accept 的线程会阻塞等待。</p>
<p><strong>至此服务端的通信流程暂告一段落，我们再看看客户端的操作。</strong></p>
<h2 id="7、connect"><a href="#7、connect" class="headerlink" title="7、connect"></a>7、connect</h2><p>客户端也需要创建一个 socket，也就是调用 socket()，这里就不赘述了，我们直接开始建连操作。</p>
<p>客户端需要与服务端建立连接，在 TCP 协议下开始经典的三次握手操作，再看一下上面画的图：</p>
<img src="/images/WEBRESOURCEea44d4a7009566a028bf7de90bad8e3b.png" style="zoom:50%;" />

<p>客户端创建完 socket 并调用 connect 之后，连接就处于 SYN_SEND 状态，当收到服务端的 SYN+ACK 之后，连接就变为 ESTABLISHED 状态，此时就代表三次握手完毕。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span><br></pre></td></tr></table></figure>

<p>调用connect需要指定远程的地址和端口进行建连，三次握手完毕之后就可以开始通信了。</p>
<p>客户端这边不需要调用 bind 操作，默认会选择源 IP 和随机端口。</p>
<p>用一幅图来小结一下建连的操作：</p>
<img src="/images/WEBRESOURCEc0376230d1f35d1e270a6f72cca5cb36.png" style="zoom: 33%;" />

<p>可以看到这里的两个阻塞点：</p>
<ul>
<li><p>connect：需要阻塞等待三次握手的完成。</p>
</li>
<li><p>accept：需要等待可用的已完成的连接，如果已完成连接队列为空，则被阻塞。</p>
</li>
</ul>
<h2 id="8、read、write"><a href="#8、read、write" class="headerlink" title="8、read、write"></a>8、read、write</h2><p>连接建立成功之后，就能开始发送和接收消息了，我们来看一下</p>
<img src="/images/WEBRESOURCEc548922136a2e1f81c42e14e9ac2728c.png" style="zoom: 50%;" />

<p>read 为读数据，从服务端来看就是等待客户端的请求，如果客户端不发请求，那么调用 read 会处于阻塞等待状态，没有数据可以读，这个应该很好理解。</p>
<p>write 为写数据，一般而言服务端接受客户端的请求之后，会进行一些逻辑处理，然后再把结果返回给客户端，这个写入也可能会被阻塞。</p>
<p>这里可能有人就会问 read 读不到数据阻塞等待可以理解，write 为什么还要阻塞，有数据不就直接发了吗？</p>
<p>因为我们用的是 TCP 协议，TCP 协议需要保证数据可靠地、有序地传输，并且给予端与端之间的流量控制。</p>
<p>所以说发送不是直接发出去，它有个发送缓冲区，我们需要把数据先拷贝到 TCP 的发送缓冲区，由 TCP 自行控制发送的时间和逻辑，有可能还有重传什么的。</p>
<p>如果我们发的过快，导致接收方处理不过来，那么接收方就会通过 TCP 协议告知：别发了！忙不过来了。发送缓存区是有大小限制的，由于无法发送，还不断调用 write 那么缓存区就满了，满了就不然你 write 了，所以 write 也会发生阻塞。</p>
<p>综上，read 和 write 都会发生阻塞。</p>
<h2 id="9、为什么网络-I-x2F-O-会被阻塞？"><a href="#9、为什么网络-I-x2F-O-会被阻塞？" class="headerlink" title="9、为什么网络 I&#x2F;O 会被阻塞？"></a>9、为什么网络 I&#x2F;O 会被阻塞？</h2><p>因为建连和通信涉及到的 accept、connect、read、write 这几个方法都可能会发生阻塞。</p>
<p>阻塞会占用当前执行的线程，使之不能进行其他操作，并且频繁阻塞唤醒切换上下文也会导致性能的下降。</p>
<p>由于阻塞的缘故，起初的解决的方案就是建立多个线程，但是随着互联网的发展，用户激增，连接数也随着激增，需要建立的线程数也随着一起增加，到后来就产生了 C10K 问题。</p>
<p>服务端顶不住了呀，咋办？</p>
<p>优化呗！</p>
<p>所以后来就弄了个非阻塞套接字，然后 I&#x2F;O多路复用、信号驱动I&#x2F;O、异步I&#x2F;O。</p>
<p>下篇我们就来好好盘盘，这几种 I&#x2F;O 模型！</p>
<h1 id="二、通透IO模型"><a href="#二、通透IO模型" class="headerlink" title="二、通透IO模型"></a>二、通透IO模型</h1><p>上篇我们已经搞懂了 socket 的通信内幕，也明白了网络 I&#x2F;O 确实会有很多阻塞点，阻塞 I&#x2F;O 随着用户数的增长只能利用增加线程的方式来处理更多的请求，而线程不仅会占用内存资源且太多的线程竞争会导致频繁地上下文切换产生巨大的开销。</p>
<p>因此，阻塞 I&#x2F;O 已经不能满足需求，所以后面大佬们不断地优化和演进，提出了多种 I&#x2F;O 模型。</p>
<p>在 UNIX 系统下，一共有五种 I&#x2F;O 模型，今天我们就来盘一盘它！</p>
<p>不过在介绍 I&#x2F;O 模型之前，我们需要先了解一下前置知识。</p>
<h2 id="1、内核态和用户态"><a href="#1、内核态和用户态" class="headerlink" title="1、内核态和用户态"></a>1、内核态和用户态</h2><p>我们的电脑可能同时运行着非常多的程序，这些程序分别来自不同公司。</p>
<p>谁也不知道在电脑上跑着的某个程序会不会发疯似得做一些奇怪的操作，比如定时把内存清空了。</p>
<p>因此 CPU 划分了非特权指令和特权指令，即cpu分为内核态和用户态，做了权限控制，一些危险的指令不会开放给普通程序，只会开放给操作系统等特权程序。</p>
<p>你可以理解为我们的代码调用不了那些可能会产生“危险”操作，而操作系统的内核代码可以调用。</p>
<p>这些“危险”的操作指：内存的分配回收，磁盘文件读写，网络数据读写等等。</p>
<p>如果我们想要执行这些操作，只能调用操作系统开放出来的 API ，也称为系统调用。</p>
<p>这就好比我们去行政大厅办事，那些敏感的操作都由官方人员帮我们处理（系统调用），所以道理都是一样的，目的都是为了防止我们(普通程序)乱来。</p>
<p>这里又有两个名词：</p>
<ul>
<li><p>用户空间</p>
</li>
<li><p>内核空间</p>
</li>
</ul>
<p>我们普通程序的代码是跑在用户空间上的，而操作系统的代码跑在内核空间上，用户空间无法直接访问内核空间的。当一个进程运行在用户空间时就处于用户态，运行在内核空间时就处于内核态。</p>
<p>当处于用户空间的程序进行系统调用，也就是调用操作系统内核提供的 API 时，就会进行上下文的切换，切换到内核态中，也时常称之为陷入内核态。</p>
<p>那为什么开头要先介绍这个知识点呢？</p>
<p>因为当程序请求获取网络数据的时候，需要经历两次拷贝：</p>
<p>程序需要等待数据从网卡拷贝到内核空间。</p>
<p>因为用户程序无法访问内核空间，所以内核又得把数据拷贝到用户空间，这样处于用户空间的程序才能访问这个数据。</p>
<p>介绍这么多就是让你理解为什么会有两次拷贝，且系统调用是有开销的，因此最好不要频繁调用。</p>
<p>然后我们今天说的 I&#x2F;O 模型之间的差距就是这拷贝的实现有所不同！</p>
<p>今天我们就以 read 调用，即读取网络数据为例子来展开 I&#x2F;O 模型。</p>
<p>发车！</p>
<h2 id="2、同步阻塞-I-x2F-O"><a href="#2、同步阻塞-I-x2F-O" class="headerlink" title="2、同步阻塞 I&#x2F;O"></a>2、同步阻塞 I&#x2F;O</h2><img src="/images/WEBRESOURCEa22f06ba2b6e01f22baf96d3a34336fe.png" style="zoom:50%;" />

<p>当用户程序的线程调用 read 获取网络数据的时候，首先这个数据得有，也就是网卡得先收到客户端的数据，然后这个数据有了之后需要拷贝到内核中，然后再被拷贝到用户空间内，这整一个过程用户线程都是被阻塞的。</p>
<p>假设没有客户端发数据过来，那么这个用户线程就会一直阻塞等着，直到有数据。即使有数据，那么两次拷贝的过程也得阻塞等着。</p>
<p>所以这称为同步阻塞 I&#x2F;O 模型。</p>
<p>它的优点很明显，简单。调用 read 之后就不管了，直到数据来了且准备好了进行处理即可。</p>
<p>缺点也很明显，一个线程对应一个连接，一直被霸占着，即使网卡没有数据到来，也同步阻塞等着。</p>
<p>我们都知道线程是属于比较重资源，这就有点浪费了。</p>
<p>所以我们不想让它这样傻等着。</p>
<p>于是就有了同步非阻塞 I&#x2F;O。</p>
<h2 id="3、同步非阻塞-I-x2F-O"><a href="#3、同步非阻塞-I-x2F-O" class="headerlink" title="3、同步非阻塞 I&#x2F;O"></a>3、同步非阻塞 I&#x2F;O</h2><img src="/images/WEBRESOURCE05997486cc6d65e30e978e7b21031b00.png" style="zoom:50%;" />

<p>从图中我们可以很清晰的看到，同步非阻塞I&#x2F;O 基于同步阻塞I&#x2F;O 进行了优化：</p>
<p>在没数据的时候可以不再傻傻地阻塞等着，而是直接返回错误，告知暂无准备就绪的数据！</p>
<p>这里要注意，从内核拷贝到用户空间这一步，用户线程还是会被阻塞的。</p>
<p>这个模型相比于同步阻塞 I&#x2F;O 而言比较灵活，比如调用 read 如果暂无数据，则线程可以先去干干别的事情，然后再来继续调用 read 看看有没有数据。</p>
<p>但是如果你的线程就是取数据然后处理数据，不干别的逻辑，那这个模型又有点问题了。</p>
<p>等于你不断地进行系统调用，如果你的服务器需要处理海量的连接，那么就需要有海量的线程不断调用，上下文切换频繁，CPU 也会忙死，做无用功而忙死。</p>
<p>那怎么办？</p>
<p>于是就有了I&#x2F;O 多路复用。</p>
<h2 id="4、I-x2F-O-多路复用"><a href="#4、I-x2F-O-多路复用" class="headerlink" title="4、I&#x2F;O 多路复用"></a>4、I&#x2F;O 多路复用</h2><img src="/images/WEBRESOURCE3ec48f0d308012f589420c9ee229d75b.png" style="zoom:50%;" />

<p>从图上来看，好像和上面的同步非阻塞 I&#x2F;O 差不多啊，其实不太一样，线程模型不一样。</p>
<p>既然同步非阻塞 I&#x2F;O 在太多的连接下频繁调用太浪费了， 那就招个专员吧。</p>
<p>这个专员工作就是管理多个连接，帮忙查看连接上是否有数据已准备就绪。</p>
<p>也就是说，可以只用一个线程查看多个连接是否有数据已准备就绪。</p>
<p>具体到代码上，这个专员就是 select ，我们可以往 select 注册需要被监听的连接，由 select 来监控它所管理的连接是否有数据已就绪，如果有则可以通知别的线程来 read 读取数据，这个 read 和之前的一样，还是会阻塞用户线程。</p>
<p>这样一来就可以用少量的线程去监控多条连接，减少了线程的数量，降低了内存的消耗且减少了上下文切换的次数，很舒服。</p>
<p>想必到此你已经理解了什么叫 I&#x2F;O 多路复用。</p>
<p>所谓的多路指的是多条连接，复用指的是用一个线程就可以监控这么多条连接。</p>
<p>看到这，你再想想，还有什么地方可以优化的？</p>
<h2 id="5、信号驱动式I-x2F-O"><a href="#5、信号驱动式I-x2F-O" class="headerlink" title="5、信号驱动式I&#x2F;O"></a>5、信号驱动式I&#x2F;O</h2><img src="/images/WEBRESOURCEcb092f632fbbf247d6f8c0eb49f110d7.png" style="zoom:50%;" />

<p>上面的 select 虽然不阻塞了，但是他得时刻去查询看看是否有数据已经准备就绪，那是不是可以让内核告诉我们数据到了而不是我们去轮询呢？</p>
<p>信号驱动 I&#x2F;O 就能实现这个功能，由内核告知数据已准备就绪，然后用户线程再去 read（还是会阻塞）。</p>
<p>听起来是不是比 I&#x2F;O 多路复用好呀？那为什么好像很少听到信号驱动 I&#x2F;O？</p>
<p><strong>为什么市面上用的都是 I&#x2F;O 多路复用而不是信号驱动?</strong></p>
<p>因为我们的应用通常用的都是 TCP 协议，而 TCP 协议的 socket 可以产生信号事件有七种。</p>
<p>也就是说不仅仅只有数据准备就绪才会发信号，其他事件也会发信号，而这个信号又是同一个信号，所以我们的应用程序无从区分到底是什么事件产生的这个信号。</p>
<p>那就麻了呀！</p>
<p>所以我们的应用基本上用不了信号驱动 I&#x2F;O，但如果你的应用程序用的是 UDP 协议，那是可以的，因为 UDP 没这么多事件。</p>
<p>因此，这么一看对我们而言信号驱动 I&#x2F;O 也不太行。</p>
<h2 id="6、异步-I-x2F-O"><a href="#6、异步-I-x2F-O" class="headerlink" title="6、异步 I&#x2F;O"></a>6、异步 I&#x2F;O</h2><img src="/images/WEBRESOURCE2505efb77af45059d05bdf36e865309f.png" style="zoom:50%;" />

<p>信号驱动 I&#x2F;O 虽然对 TCP 不太友好，但是这个思路对的：往异步发展，但是它并没有完全异步，因为其后面那段 read 还是会阻塞用户线程，所以它算是半异步。</p>
<p>因此，我们得想下如何弄成全异步的，也就是把 read 那步阻塞也省了。</p>
<p>其实思路很清晰：让内核直接把数据拷贝到用户空间之后再告知用户线程，来实现真正的非阻塞I&#x2F;O！</p>
<p>所以异步 I&#x2F;O 其实就是用户线程调用 aio_read ，然后包括将数据从内核拷贝到用户空间那步，所有操作都由内核完成，当内核操作完毕之后，再调用之前设置的回调，此时用户线程就拿着已经拷贝到用户空间的数据可以继续执行后续操作。</p>
<p>在整个过程中，用户线程没有任何阻塞点，这才是真正的非阻塞I&#x2F;O。</p>
<p>那么问题又来了:</p>
<h2 id="7、为什么常用的还是I-x2F-O多路复用，而不是异步I-x2F-O？"><a href="#7、为什么常用的还是I-x2F-O多路复用，而不是异步I-x2F-O？" class="headerlink" title="7、为什么常用的还是I&#x2F;O多路复用，而不是异步I&#x2F;O？"></a>7、为什么常用的还是I&#x2F;O多路复用，而不是异步I&#x2F;O？</h2><p>因为 Linux 对异步 I&#x2F;O 的支持不足，你可以认为还未完全实现，所以用不了异步 I&#x2F;O。</p>
<p>这里可能有人会说不对呀，像 Tomcat 都实现了 AIO的实现类，其实像这些组件或者你使用的一些类库看起来支持了 AIO(异步I&#x2F;O)，实际上底层实现是用 epoll 模拟实现的。</p>
<p>而 Windows 是实现了真正的 AIO，不过我们的服务器一般都是部署在 Linux 上的，所以主流还是 I&#x2F;O 多路复用。</p>
<h1 id="三、搞懂-select-poll-epoll"><a href="#三、搞懂-select-poll-epoll" class="headerlink" title="三、搞懂 select_poll_epoll"></a>三、搞懂 select_poll_epoll</h1><p>首先，我们知道 select&#x2F;poll&#x2F;epoll 是用来实现多路复用的，即一个线程利用它们即可 hold 住多个 socket。</p>
<p>按照这个思路，线程不可被任何一个被管理的 Socket 阻塞，且任一个 Socket 来数据之后都得告知 select&#x2F;poll&#x2F;epoll 线程。</p>
<p>想想看，这应该如何实现呢？</p>
<h2 id="1、我们拿-select-的逻辑来分析下"><a href="#1、我们拿-select-的逻辑来分析下" class="headerlink" title="1、我们拿 select 的逻辑来分析下"></a>1、我们拿 select 的逻辑来分析下</h2><p>按照我们的理解，select 管理多个 Socket 的模型如下图所示：</p>
<img src="/images/WEBRESOURCEa62fa87c94b21c7ee729496201a12262.png" style="zoom:50%;" />

<p>这里要注意一下内核态和用户态的交互，用户程序访问不了内核空间。</p>
<p>所以，我们调用 select 会把所有要管理的 socket 的 fd (文件描述符，Linux下皆为文件，简单理解就是通过 fd 能找到这个 socket)传到内核中。</p>
<p>此时，要遍历所有 socket，看看是否有感兴趣的事件发生。如果没有一个 socket 有事件发生，那么 select 的线程就需要让出 cpu 阻塞等待，这个等待可以是不设置超时时间的死等，也可以是设置 timeout 的有超时时间的等待。</p>
<p>假设此时客户端发送了数据，网卡接收到的数据塞到对应的 socket 的接收队列中，此时 socket 知道来数据了，那如何唤醒 select 呢？</p>
<p>其实每个 socket 有个属于自己的睡眠队列，select 会安排一个内应，即在被管理的 socket 的睡眠队列里面塞入一个 entry。</p>
<img src="/images/WEBRESOURCE813c728c1846035bf9bda076c83e7728.png" style="zoom:50%;" />

<p>当 socket 接收到网卡的数据后，就会去它的睡眠队列里遍历 entry，调用 entry 设置的 callback 方法，这个 callback 方法里就能唤醒 select ！</p>
<p>所以 select 在每个被它管理的 socket 的睡眠队列里都塞入一个与它相关的 entry，这样不论哪个 socket 来数据了，它立马就能被唤醒然后干活！</p>
<p>但是，select 的实现不太好，因为唤醒的 select 此时只知道来活了，并不知道具体是哪个 socket 来数据了，所以只能傻傻地遍历所有 socket ，看看到底是哪个 scoket 来活了，然后把所有来活的 socket 封装成事件返回。</p>
<p>这样用户程序就能获得发生的事件，然后进行 I&#x2F;O 和业务处理了。</p>
<p>这就是 select 的实现逻辑，理解起来应该不难。</p>
<p>这里再提一嘴 select 的限制，因为被管理的 socket fd 需要从用户空间拷贝到内核空间，为了控制拷贝的大小而做了限制，即每个 select 能拷贝的 fds 集合大小只有1024。</p>
<p>然后要改的话只能修改宏…再重新编译内核。网上很多文章都是这样说的，但是（没错有个但是）。</p>
<p>我看了一篇文章，确实有这个宏，值也是 1024，但内核根本没有限制 fds 集合的大小。然后托人问了个内核大佬，大佬说内核确实没做限制，glibc那层做了。</p>
<p>所以…重新编译内核？那篇文章放文末。</p>
<h2 id="2、poll"><a href="#2、poll" class="headerlink" title="2、poll"></a>2、poll</h2><p>poll 这玩意相比于 select 主要就是优化了 fds 的结构，不再是 bit 数组了，而是一个叫 pollfd 的玩意，反正就是不用管啥 1024 的限制了。</p>
<p>不过现在也没人用 poll，我就不多说了。</p>
<h2 id="3、epoll"><a href="#3、epoll" class="headerlink" title="3、epoll"></a>3、epoll</h2><p>这个就是重点了。</p>
<p>相信看了 select 的实现，我们稍微思考下，就能想出几个可以优化的点。</p>
<p>比如，为什么每次 select 需要把监控的 fds 传输到内核里？不能在内核里维护个？</p>
<p>为什么 socket 只唤醒 select，不能告诉它是哪个 socket 来数据了？</p>
<p>epoll 主要就是基于上面两点做了优化。</p>
<p>首先，搞了个叫 epoll_ctl 的方法，这方法就是用来管理维护 epoll 所监控的哪些 socket。</p>
<p>如果你的 epoll 要新加一个 socket 来管理，那就调用 epoll_ctl，要删除一个 socket 也调用 epoll_ctl，通过不同的入参来控制增删改。</p>
<img src="/images/WEBRESOURCEbebf84ed0d9e49af07fc26bcc9ec0ad3.png" style="zoom:50%;" />

<p>这样，在内核里面就维护了此 epoll 管理的 socket 集合，这样就不用每次调用的时候都得把所有管理的 fds 拷贝到内核了。</p>
<p>对了，这个 socket 集合是用红黑树实现的。</p>
<p>然后和 select 类似，每个 socket 的睡眠队列里都会加个 entry，当每个 socket 来数据之后，同样也会调用 entry 对应的 callback。</p>
<p>与 select 不同的是，引入了一个 ready_list 双向链表，callback 里面会把当前的 socket 加入到 ready_list 然后唤醒 epoll。</p>
<img src="/images/WEBRESOURCE0a033285ac4031e5f22fc19f61963ad3.png" style="zoom: 33%;" />

<p>这样被唤醒的 epoll 只需要遍历 ready_list 即可，这个链表里一定是有数据可读的 socket，相比于 select 就不会做无用的遍历了。</p>
<p>同时收集到的可读的 fd 按理是要拷贝到用户空间的，这里又做了个优化，利用了 mmp，让用户空间和内核空间映射到同一块内存中，这样就避免了拷贝。</p>
<p>完美啊~</p>
<p>这就是 epoll 基于 select 所作的优化，还有一些差别没细说，比如 epoll 是阻塞睡眠在一个 single_epoll_wait_list 而不是 socket 的睡眠队列等等，我就不提了，理解上面的这些已经够了。</p>
<h2 id="4、ET-lt"><a href="#4、ET-lt" class="headerlink" title="4、ET&lt;"></a>4、ET&lt;</h2><p>都谈到 epoll 了，避免不了要扯扯 ET 和 LT 两个模式。</p>
<p>ET，边沿触发。按照上面的逻辑就是 epoll 遍历 ready_list 的时候，会把 socket 从 ready_list 里面移除，然后读取这个 scoket 的事件。</p>
<p>而 LT，水平触发，有点不一样，在这个模式下 epoll 遍历 ready_list 的时候，会把 socket 从 ready_list 里面移除，然后读取这个 scoket 的事件，如果这个 socket 返回了感兴趣的事件，那么当前这个 socket 会再被加入到 ready_list 中，这样下次调用 epoll_wait 的时候，还能拿到这个 socket。</p>
<p>这就是这两者最本质的区别了。</p>
<p>看到这有人会问，这两种模式的使用会造成哪种不一样的结果？</p>
<p>如果此时一个客户端同时发来了 5 个数据包，按正常的逻辑，只需要唤醒一次 epoll ，把当前 socket 加一次到 ready_list 就行了，不需要加 5 次。然后用户程序可以把 socket 接收队列的所有数据包都读完。</p>
<p>但假设用户程序就读了一个包，然后处理报错了，后面不读了，那后面的 4 个包咋办？</p>
<p>如果是 ET 模式，就读不了了，因为没有把 socket 加入到 ready_list 的触发条件了。除非这个客户端发了新的数据包过来，这样才会再把当前 socket 加入到 ready_list，在新包过来之前，这 4 个数据包都不会被读到。</p>
<p>而 LT 模式不一样，因为每次读完有感兴趣的事件发生之后，会把当前 socket 再加入到 ready_list，所以下次肯定能读到这个 socket，所以后面的 4 个数据包会被访问到，不论客户端是否发送新包。</p>
<p>至此，我想你应该理解什么是 ET ，什么是 LT 了，而不用对着一些什么状态变更触发这些不易理解的名词而发晕。</p>
<p>最后</p>
<p>好了，今天的分析到此完毕，我个人觉得对 select&#x2F;poll&#x2F;epoll 的理解到这个程度就差不多了，当然还有很多细节，需要自行去看源码探究，问我我也不懂，这些都是阅读网上的源码分析文章得出的结论。</p>
<p>我也不建议读的那么深，毕竟人的精力有限对吧，有涉及到相关底层优化的时候，再去研究也不迟。</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/dog250/article/details/105896693(select%E7%9C%9F%E7%9A%84%E5%8F%971024%E9%99%90%E5%88%B6%E5%90%97%EF%BC%9F)">https://blog.csdn.net/dog250/article/details/105896693(select真的受1024限制吗？)</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/dog250/article/details/50528373">https://blog.csdn.net/dog250/article/details/50528373</a></p>
</li>
</ul>
<h1 id="四、同步、异步、阻塞、非阻塞"><a href="#四、同步、异步、阻塞、非阻塞" class="headerlink" title="四、同步、异步、阻塞、非阻塞"></a>四、同步、异步、阻塞、非阻塞</h1><h2 id="1、同步-amp-异步"><a href="#1、同步-amp-异步" class="headerlink" title="1、同步&amp;异步"></a>1、同步&amp;异步</h2><p>同步和异步指的是：当前线程是否需要等待方法调用执行完毕。</p>
<p>比如你调用一个搬运一百块石头的方法：</p>
<ul>
<li>同步指的是调用这个方法，你的线程需要等待这一百块石头搬完，然后得到搬完了的结果，接着再继续执行剩下的代码逻辑。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同步方式</span></span><br><span class="line"></span><br><span class="line">result = 搬一百块石头();</span><br><span class="line"><span class="comment">//需等待搬完的结果，才能执行下面的逻辑</span></span><br><span class="line"><span class="keyword">if</span>(result) &#123;</span><br><span class="line">石头搬完了发工资();</span><br><span class="line">&#125;</span><br><span class="line">计算下一次搬石头的任务()；</span><br></pre></td></tr></table></figure>

<ul>
<li>异步指的是调用这个方法，立马就直接返回，不必等候这一百块石头还未搬完，可以立马执行后面的代码逻辑，然后利用回调或者事件通知的方式得到石头已经搬完的结果。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//异步方式</span></span><br><span class="line"></span><br><span class="line">搬一百块石头(&#123;</span><br><span class="line">    <span class="comment">//回调</span></span><br><span class="line">	石头搬完了发工资();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//不必等待石头搬完，立马执行下面的逻辑</span></span><br><span class="line">计算下一次搬石头的任务()；</span><br></pre></td></tr></table></figure>

<p>可以很直观的看出，同步和异步就是调用方式的不同，这使得我们的编码方式也有所不同。</p>
<p>在异步调用下的代码逻辑相对而言不太直观，需要借助回调或事件通知，这在复杂逻辑下对编码能力的要求较高。而同步调用就是直来直去，等待执行完毕然后拿到结果紧接着执行下面的逻辑，对编码能力的要求较低，也更不容易出错。</p>
<p>所以你会发现有很多方法它是异步调用的方式，但是最终的使用还是异步转同步。</p>
<p>比如你向线程池提交一个任务，得到一个 future，此时是异步的，然后你在紧接着在代码里调用 future.get()，那就变成等待这个任务执行完成，这就是所谓的异步转同步，像 Dubbo RPC 调用同步得到返回结果就是这样实现的。</p>
<h2 id="2、阻塞-amp-非阻塞"><a href="#2、阻塞-amp-非阻塞" class="headerlink" title="2、阻塞&amp;非阻塞"></a>2、阻塞&amp;非阻塞</h2><p>阻塞和非阻塞指的是：当前接口数据还未准备就绪时，线程是否被阻塞挂起。</p>
<p>何为阻塞挂起？就是当前线程还处于 CPU 时间片当中，调用了阻塞的方法，由于数据未准备就绪，则时间片还未到就让出 CPU。</p>
<p>所以阻塞和同步看起来都是等，但是本质上它们不一样，同步的时候可没有让出 CPU。</p>
<p>而非阻塞就是当前接口数据还未准备就绪时，线程不会被阻塞挂起，可以不断轮询请求接口，看看数据是否已经准备就绪。</p>
<p>至此我们可以得到一个结论：</p>
<ul>
<li><p>同步&amp;异步指：当数据还未处理完成时，代码的逻辑处理方式不同。</p>
</li>
<li><p>阻塞&amp;非阻塞指：当数据还未处理完成时(未就绪)，线程的状态。</p>
</li>
</ul>
<p>所以同步&amp;异步其实是处于框架这种高层次维度来看待的，而阻塞&amp;非阻塞往往针对底层的系统调用方面来抉择，也就是说两者是从不同维度来考虑的。</p>
<h2 id="3、cpu时间片："><a href="#3、cpu时间片：" class="headerlink" title="3、cpu时间片："></a>3、cpu时间片：</h2><p>时间片即CPU分配给各个程序的时间，每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间，使各个程序从表面上看是同时进行的。</p>
<p>如果在时间片结束时进程还在运行，则CPU将被剥夺并分配给另一个进程。如果进程在时间片结束前阻塞或结束，则CPU当即进行切换。而不会造成CPU资源浪费。</p>
<p>在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。</p>
<p>但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。</p>
<h2 id="4、再结合-I-x2F-O-来看"><a href="#4、再结合-I-x2F-O-来看" class="headerlink" title="4、再结合 I&#x2F;O 来看"></a>4、再结合 I&#x2F;O 来看</h2><p>前提：程序和硬件之间隔了个操作系统，而为了安全考虑，Linux 系统分了：用户态和内核态</p>
<p>在这个前提下，我们再明确 I&#x2F;O 操作有两个步骤：</p>
<ol>
<li><p>发起 I&#x2F;O 请求</p>
</li>
<li><p>实际 I&#x2F;O 读写，即数据从内核缓存拷贝到用户空间</p>
</li>
</ol>
<p>阻塞 I&#x2F;O 和非阻塞 I&#x2F;O。按照上文，其实指的就是用户线程是否被阻塞，这里指代的步骤1（发起I&#x2F;O请求）。</p>
<ul>
<li><p>阻塞 I&#x2F;O，指用户线程发起 I&#x2F;O 请求的时候，如果数据还未准备就绪（例如暂无网络数据接收），就会阻塞当前线程，让出 CPU。</p>
</li>
<li><p>非阻塞 I&#x2F;O，指用户线程发起 I&#x2F;O 请求的时候，如果数据还未准备就绪（例如暂无网络数据接收），也不会阻塞当前线程，可以继续执行后续的任务。</p>
</li>
</ul>
<p>可以发现，这里的阻塞和非阻塞其实是指用户线程是否会被阻塞。</p>
<p>同步 I&#x2F;O 和异步 I&#x2F;O。按照上文，我们可以得知这就是根据 I&#x2F;O 响应方式不同而划分的。</p>
<ul>
<li><p>同步 I&#x2F;O，指用户线程发起 I&#x2F;O 请求的时候，数据是有的，那么将进行步骤2（实际 I&#x2F;O 读写，即数据从内核缓存拷贝到用户空间），这个过程用户线程是要等待着拷贝完成。</p>
</li>
<li><p>异步 I&#x2F;O，指用户线程发起 I&#x2F;O 请求的时候，数据是有的，那么将进行步骤2（实际 I&#x2F;O 读写，即数据从内核缓存拷贝到用户空间），拷贝的过程中不需要用户线程等待，用户线程可以去执行其它逻辑，等内核将数据从内核空间拷贝到用户空间后，用户线程会得到一个“通知”。</p>
</li>
</ul>
<p>再仔细思考下，在 I&#x2F;O 场景下同步和异步说的其实是内核的实现，因为拷贝的执行者是内核，一种是同步将数据拷贝到用户空间，用户线程是需要等着的。一个是通过异步的方式，用户线程不用等，在拷贝完之后，内核会调用指定的回调函数。</p>
<p>如果不理解上面，就只需记住：</p>
<ul>
<li><p>同步I&#x2F;O：指的是用户线程会需要等待步骤 2 执行完毕。</p>
</li>
<li><p>异步I&#x2F;O：指的是用户线程不需要等待步骤 2 执行。</p>
</li>
</ul>
<p>好了，如果以上的概念你都已经理解了的话，那么平日里我们所说的同步阻塞I&#x2F;O，同步非阻塞I&#x2F;O等其实就是把上面的两个步骤合起来看，应该不难理解。</p>
<p>我再简单的总结一下，关于 I&#x2F;O 的阻塞、非阻塞、同步、异步：</p>
<ul>
<li><p>阻塞和非阻塞指的是发起 I&#x2F;O 请求后，用户线程状态的不同，阻塞I&#x2F;O在数据未准备就绪的时候会阻塞当前用户线程，而非阻塞 I&#x2F;O 会立马返回一个错误，不会阻塞当前用户线程。</p>
</li>
<li><p>同步和异步是指，内核的 I&#x2F;O 拷贝实现，当数据准备就绪后，需要将内核空间的数据拷贝至用户空间，如果是同步 I&#x2F;O 那么用户线程会等待拷贝的完成，而异步 I&#x2F;O则这个拷贝过程用户线程该干嘛可以去干吗，当内核拷贝完毕之后会“通知”用户线程。</p>
</li>
</ul>
<h1 id="五、干翻Netty-写一个底层通信框架需要考虑哪些"><a href="#五、干翻Netty-写一个底层通信框架需要考虑哪些" class="headerlink" title="五、干翻Netty 写一个底层通信框架需要考虑哪些"></a>五、干翻Netty 写一个底层通信框架需要考虑哪些</h1><h2 id="1、为什么Netty使用NIO，而不使用AIO"><a href="#1、为什么Netty使用NIO，而不使用AIO" class="headerlink" title="1、为什么Netty使用NIO，而不使用AIO"></a>1、为什么Netty使用NIO，而不使用AIO</h2><h3 id="NIO和AIO的区别"><a href="#NIO和AIO的区别" class="headerlink" title="NIO和AIO的区别"></a>NIO和AIO的区别</h3><h4 id="NIO模型（同步非阻塞"><a href="#NIO模型（同步非阻塞" class="headerlink" title="NIO模型（同步非阻塞)"></a>NIO模型（同步非阻塞)</h4><p>NIO有同步阻塞和同步非阻塞两种模式，一般讲的是同步非阻塞，服务器实现模式为一个请求一个线程，但客户端发送的连接请求都会注册到一个多路复用器上，多路利用器轮询到连接有I&#x2F;O请求时才启动一个线程进行处理。</p>
<h4 id="AIO模型-异步非阻塞）"><a href="#AIO模型-异步非阻塞）" class="headerlink" title="AIO模型 (异步非阻塞）"></a>AIO模型 (异步非阻塞）</h4><p>服务器实现模式为一个有效请求一个线程，客户端的I&#x2F;O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。</p>
<p>然后看下Netty作者在这个问题上的原话</p>
<p>Not faster than NIO(epoll) on unix systems (which is true) 译：在UNIX系统上不比NIO快</p>
<p>There is no daragream support 译：不支持数据报</p>
<p>Unnecessary threading model(too much abstraction without usage) 译：不必要的线程模型</p>
<p>所以我们可以总结出以下几点:</p>
<ul>
<li><p>在LINUX系统上，AIO底层实现仍使用Epoll，没有很好的实现AIO，因此性能上没有明显优势，而且被JDK封装了一层不容易优化</p>
</li>
<li><p>Netty整体架构是基本reactor模型，而aio是proactor模型，混合在一起会比较混乱</p>
</li>
<li><p>aio还有个缺点是接收数据需要预先分配缓冲区，而不是NIO那种需要接收时才需要分配缓存，所以对连接数量非常大但流量小的情况，内存浪费很多</p>
</li>
<li><p>linux上aio不够成熟，处理回调的结果速度跟不到处理需求，供不应求，造成处理速度有瓶颈</p>
</li>
</ul>
<hr>
<p>这篇算是 Netty 系列的开篇，开篇不会很快进入细节，开篇需要从高纬度入手，总览全局。</p>
<p>我有个习惯，在新学一个框架的时候，在有一定的基础下，我会闭上眼睛思考这个框架应该需要哪些核心要点。</p>
<p>拿 Netty 举例，我会假设老板给我个任务，要我写一个底层通信框架，我要怎么写？都有哪些方面需要考虑？</p>
<p>通过这种驱动式自我提问，来推动自己不得不去思考，被动让脑子转！这样会让你理解地更深刻。</p>
<p>下面我们一起来思考下这个问题。</p>
<h2 id="2、写一个底层通信框架需要考虑哪些？"><a href="#2、写一个底层通信框架需要考虑哪些？" class="headerlink" title="2、写一个底层通信框架需要考虑哪些？"></a>2、写一个底层通信框架需要考虑哪些？</h2><p>关于通信，我第一个想到的就是网络协议，好在一些协议底层都已经帮我们实现，但是要通信还是避免不了和底层打交道。比如，要调用操作系统的接口来发送数据给远程，如果要我们去实现还得去了解操作系统的各种接口，感觉有点麻烦。</p>
<p>但好在，这样底层的交互，身为一门语言肯定是已经提供了封装的，对于 Java 而言提供了 NIO。</p>
<p>所以，通信的一些基本操作，包括创建 socket、建立连接、发送消息、接收消息等等，这些 NIO 都提供了。</p>
<p>这样岂不是直接用 Java NIO 就行了？</p>
<p>用肯定是要用的，但是这种语言类库提供的接口，需要给予上层更多自由的配置，也就是它能提供精细化地调用，但是对于通常的使用而言过于复杂。简而言之，就是封装的不够完美，不够简单。</p>
<p>我们追求的是仪表盘只需暴露几个键，只要按几个键应用即可成功的运行，所以我们需要基于 Java NIO 做封装，把一些复杂的配置隐藏起来，对外暴露出更加易用的接口。</p>
<p>所以，我们的第一个目标已经明确了，利用 Java NIO 提供的能力并基于它做封装，尽量简化配置，易于使用。(其实框架都这样，例如 Mybatis 之类的，还是得基于 JDBC 的能力，在此之上封装)</p>
<p>大体目标有了，然后得丰富一下功能性。</p>
<p>由于网络通信都是字节流，所以我们还要提供编解码的支持，且需要支持各种协议，毕竟身为一个框架需要供各种团队使用，每个团队涉及的通信协议可能有所不同，因此框架需要尽可能的支持市面上常见的协议，比如 HTTP、DNS 等等，当然也要方便的定制自定义协议。</p>
<p>对了，还需要考虑粘包和拆包等问题，支持分隔符切分、固定长度等等，给予“客户”更多方便的选择！</p>
<p>实现上面这些，一些基本的通信需求满足了，然后再考虑性能。</p>
<p>身为一个网络通信框架，我们需要考虑连接的管理，毕竟资源是有限的，所以合理的连接数很重要，因此我们需要提供心跳、检查空闲连接等功能来管理连接。</p>
<p>还有 I&#x2F;O 模型，现在这个“行情”不说了，直接多路复用，用更少的线程处理更多的请求， hold 住海量连接。等啥时候 Linux 完美支持 AIO 了再上个 AIO，不过 Linux 提供了 epoll ，所以如果服务是跑在 Linux 上的就用 epoll，反之用 select。</p>
<p>对了，网上经常还会提到零拷贝，这个肯定是要的，比如发送一些文件的时候直接利用零拷贝减少拷贝次数，并且还能用 DirectBuffer 将数据放置堆外，省去了堆内外的一次拷贝，提升性能。</p>
<p>当然对应的还得需要做好内存管理，这个我想可以参考参考 Linux 的伙伴系统。</p>
<p>关于线程模型，也得研究研究，例如 accept 线程与 reactor 线程(I&#x2F;O线程)与业务处理线程的编排等等，在大流量下合理的线程模型会减少线程切换次数，提高性能，这很关键。</p>
<p>然后一个框架想要易用，不仅要适配不同团队的不同需求，还需方便适配同一团队的需求变更。这就需要框架必须要提供十分方便的定制化、插件化功能，这又该怎么设计？责任链模式就适合这个，配合事件驱动，好像挺完美的。</p>
<p>我个人认为，身为一个框架，提供诸多开箱即用的功能、接口易用、性能好、易扩展，那简直就是完美！</p>
<p>总之，通信框架的思考可以从功能出发：配置启动服务、建立连接、接收数据、处理业务、发送数据、关闭连接、关闭服务。从这条主线入手，分别考虑上述说的，易用的接口、I&#x2F;O 模型、编解码、开箱即用的协议支持、线程模型、连接管理、内存管理等。</p>
<p>综上，这就是我个人认为实现一个底层通信框架要思考的一些核心点，当然还有很多细节和一些锦上添花的功能，这还得再细细的盘一盘。</p>
<p>可以看到，要做一款通信框架，并没有那么简单，有很多需要考虑，这也是为什么那么多中间件底层通信框架不自己实现，而是都利用 Netty 的原因。</p>
<p>因为 Netty 将这些都实现了。</p>
<h2 id="3、什么是Netty？"><a href="#3、什么是Netty？" class="headerlink" title="3、什么是Netty？"></a>3、什么是Netty？</h2><p>它是高性能 Java 网络通信的底层框架，可能你听过的很多中间件底层通信框架用的都是它，例如 RocketMQ、Dubbo、Elasticsearch、Cassandra等。</p>
<h3 id="它为什么这么流行？为什么这么多中间件都在它之上构建？"><a href="#它为什么这么流行？为什么这么多中间件都在它之上构建？" class="headerlink" title="它为什么这么流行？为什么这么多中间件都在它之上构建？"></a>它为什么这么流行？为什么这么多中间件都在它之上构建？</h3><h4 id="易用"><a href="#易用" class="headerlink" title="易用"></a>易用</h4><p>对 Java 的 NIO 进行了封装，屏蔽了 NIO 使用的复杂性，简化了网络通信的开发。</p>
<p>且支持众多协议，不仅仅 HTTP、HTTP2、DNS、Redis 协议等等。</p>
<p>网络编程需要考虑粘包和拆包问题，连接的管理，编解码的处理，Netty都为你定制好了，开箱即用。</p>
<p>还提供的内存泄漏检测，IP过滤、流量整型等高级功能。</p>
<h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>良好的I&#x2F;O模型。</p>
<p>Netty 基于 Java NIO 封装实现了 I&#x2F;O 多路复用，可由一个线程轮询多个底层 channel，减少了线程资源，也减少了多线程切换带来的开销，能更好的处理海量连接，提升系统的性能。</p>
<p>在 Linux 环境下也会用更优的 epoll 模型。</p>
<p>运用零拷贝技术。不仅利用操作系统提供的零拷贝，也基于堆外内存省了一次 JVM 堆内外之间的拷贝。</p>
<p>对象池技术，通过对象的复用，避免频繁创建和销毁带来的开销。</p>
<h4 id="扩展性"><a href="#扩展性" class="headerlink" title="扩展性"></a>扩展性</h4><p>基于事件驱动模型，将业务实现剥离成一个个 ChannelHandler ，利用责任链模式，可以很好的根据不同业务进行扩展，使用者只需要实现相关的 ChannelHandler 即可，框架与业务隔离。</p>
<p>可以根据情况配置线程模型，例如主从 Reactor ，主多从 Reactor 等等。</p>
<p>最后</p>
<p>这篇，只是从一个很高的纬度来谈谈一个底层网络通信框架的实现需要包含哪些核心点，以及 Netty 的一个很粗的概况，等之后系列完结了之后，再来一个详细的全局总结。</p>
<p>下篇，开始总览 Netty 的一些核心组件。</p>
<p>这次的 Netty 系列，我们一起学完后，我相信 Netty 或许能成为你以后面试的加分项，因为它不仅涵盖的知识面广，且有很多精妙的设计。</p>
<h2 id="4、什么是粘包拆包"><a href="#4、什么是粘包拆包" class="headerlink" title="4、什么是粘包拆包"></a>4、什么是粘包拆包</h2><p>有过tcp编程的伙伴可能都知道，无论是服务端还是客户端，发送或读取消息的时候，都需要考虑粘包&#x2F;拆包问题。</p>
<h4 id="4-1-什么是粘包-x2F-拆包"><a href="#4-1-什么是粘包-x2F-拆包" class="headerlink" title="4.1 什么是粘包&#x2F;拆包"></a>4.1 什么是粘包&#x2F;拆包</h4><p>TCP是个“流”式的协议，所谓流，就像河里的水，中间没有边界。TCP传输的数据，在网络上就是一连串的数据，没有分界线。TCP协议的底层，并不了解上层业务的具体定义，它会根据TCP缓冲区的实际情况进行包的划分。使用了块的合并优化算法（TCP使用了Nagle算法），在业务层面认为一个完整的包，可能会被TCP拆分成多个小包进行发送，也可能把多个小的包封装成一个大的数据包进行发送，这就是所谓的TCP粘包拆包问题。</p>
<img src="/images/WEBRESOURCEf8a3b2e7da10f61b10cfb5838991bc0f.png" style="zoom:50%;" />

<p>客户端发送了两个数据包P1和P2给服务端，服务端一次读取到的字节数是不确定的，可能存在以下4种情况：</p>
<p>（1）服务端分两次读取到了两个独立的数据包P1和P2，没有发送粘包和拆包；</p>
<p>（2）服务端一次读到了两个数据包，P1和P2粘在一起，这就是TCP粘包情况；</p>
<p>（3）服务端分两次读取到了两个数据包，第一次读取了完整的P1包和P2包的一部分，第二次读取到了P2包的剩余部分，这被称为TCP拆包；</p>
<p>（4）服务端分两次读取了两个数据包，第一次读取了P1包的一部分，第二次读取到了P1包的剩余部分，这也是TCP拆包；</p>
<h4 id="4-2-TCP粘包-x2F-拆包发生的原因"><a href="#4-2-TCP粘包-x2F-拆包发生的原因" class="headerlink" title="4.2 TCP粘包&#x2F;拆包发生的原因"></a>4.2 TCP粘包&#x2F;拆包发生的原因</h4><p>TCP数据流最终发到目的地，需要通过以太网协议封装成一个个的以太网帧发送出去，以太网数据帧大小最小64字节，最大1518字节，除去header部分，其数据payload为46到1500字节。所以如果以太网帧的payload大于MTU（默认1500字节）就需要进行拆包。</p>
<h4 id="4-3-粘包拆包问题解决方法"><a href="#4-3-粘包拆包问题解决方法" class="headerlink" title="4.3 粘包拆包问题解决方法"></a>4.3 粘包拆包问题解决方法</h4><p>由于TCP协议底层无法理解上层的业务数据，所以在底层是无法保证数据包不被拆分和重组的，所以，这个问题只能通过上层的应用层协议设计来解决，常见方案如下：</p>
<p>（1）消息定长，发送方和接收方规定固定大小的消息长度，例如每个报文大小固定为200字节，如果不够，空位补空格；</p>
<p>（2）增加特殊字符进行分割，例如FTP协议；</p>
<p>（3）自定义协议，将消息分为消息头和消息体，消息头中包含消息总长度，这样服务端就可以知道每个数据包的具体长度了，知道了发送数据包的具体边界后，就可以解决粘包和拆包问题了；</p>
<h4 id="4-4-为什么UDP不会发生粘包-x2F-拆包问题"><a href="#4-4-为什么UDP不会发生粘包-x2F-拆包问题" class="headerlink" title="4.4 为什么UDP不会发生粘包&#x2F;拆包问题"></a>4.4 为什么UDP不会发生粘包&#x2F;拆包问题</h4><p>UDP是无连接的，面向消息的，提供高效率服务。不会使用块的合并优化算法（TCP使用了Nagle算法）。UDP支持的是一对多的模式，所以接收端的缓冲区采用了链式结构来缓存每一个到达的数据包，在每个UDP包中就有了消息头（消息来源地址，端口等信息），这样，对于接收端来说，就容易进行区分处理了。即面向消息的通信是有消息边界的。所以udp根本不会粘包，但是会丢数据，不可靠。</p>
<p>笔者使用jdk的nio，写了个简单的发送文件的客户端，每次发送文件协议格式：数据包总长度|文件名长度|文件名|文件内容长度|文件内容，时间有限，服务端程序还未写完，稍后会继续完成的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sendFile</span><span class="params">(String hostname, <span class="type">int</span> nioPort, <span class="type">byte</span>[] file, String filename, <span class="type">long</span> fileSize)</span> &#123;</span><br><span class="line">    <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        channel = SocketChannel.open();</span><br><span class="line">        channel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        channel.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(hostname, nioPort));</span><br><span class="line">        selector = Selector.open();</span><br><span class="line">        channel.register(selector, SelectionKey.OP_CONNECT);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            selector.select();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; keysIterator = selector.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (keysIterator.hasNext()) &#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> keysIterator.next();</span><br><span class="line">                keysIterator.remove();</span><br><span class="line">                <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">                    channel = (SocketChannel) key.channel();</span><br><span class="line">                    <span class="keyword">if</span> (channel.isConnectionPending()) &#123;</span><br><span class="line">                        channel.finishConnect();</span><br><span class="line">                        <span class="type">byte</span>[] filenameBytes = filename.getBytes();</span><br><span class="line">                        <span class="type">long</span> <span class="variable">totalLen</span> <span class="operator">=</span> <span class="number">4</span> + filenameBytes.length + <span class="number">8</span> + fileSize;</span><br><span class="line">                        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate((<span class="type">int</span>) fileSize * <span class="number">2</span> + filenameBytes.length);</span><br><span class="line">                        buffer.putLong(totalLen);</span><br><span class="line">                        buffer.putInt(filenameBytes.length);</span><br><span class="line">                        buffer.put(filenameBytes);</span><br><span class="line">                        buffer.putLong(fileSize);</span><br><span class="line">                        buffer.put(file);</span><br><span class="line">                        buffer.flip();</span><br><span class="line">                        <span class="type">int</span> <span class="variable">sentData</span> <span class="operator">=</span> channel.write(buffer);</span><br><span class="line">                        System.out.println(<span class="string">&quot;已经发送了&quot;</span> + sentData + <span class="string">&quot;字节的数据到&quot;</span> + hostname);</span><br><span class="line">                        channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                    channel = (SocketChannel) key.channel();</span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> channel.read(buffer);</span><br><span class="line">                    <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;收到服务端的响应：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(buffer.array(), <span class="number">0</span>, len));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                channel.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (selector != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                selector.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「wh柒八九」的原创文章，遵循CC <span class="number">4.0</span> BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https:<span class="comment">//blog.csdn.net/qq_31960623/article/details/121056626</span></span><br></pre></td></tr></table></figure>

<h4 id="4-5netty是如何解决粘包拆包问题的"><a href="#4-5netty是如何解决粘包拆包问题的" class="headerlink" title="4.5netty是如何解决粘包拆包问题的"></a>4.5netty是如何解决粘包拆包问题的</h4><p>基于jdk原生的socket或者nio编程，解决粘包拆包问题毕竟麻烦，作为一款非常强大的网络通信框架，netty提供了多种编码器用于解决粘包拆包问题，只要掌握这些类库的使用，你就不用关心如何解决粘包拆包问题了。</p>
<p>常见编码器：</p>
<p>LineBasedFrameDecoder，基于行的解码器，遇到 “\n”、”\r\n”会被作为行分隔符；</p>
<p>FixedLengthFrameDecoder，基于固定长度的解码器；</p>
<p>DelimiterBasedFrameDecoder，基于分隔符的振解码器；</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://issac2e.github.io">issac</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://issac2e.github.io/2023/01/20/io/io%E5%AD%97%E5%85%B8/">https://issac2e.github.io/2023/01/20/io/io%E5%AD%97%E5%85%B8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/io/">io</a><a class="post-meta__tags" href="/tags/socket/">socket</a><a class="post-meta__tags" href="/tags/netty/">netty</a></div><div class="post_share"><div class="social-share" data-image="/./img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/01/28/UofG/Algorithms%20and%20Data%20Structures/" title="Algorithms and Data Structures"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">Algorithms and Data Structures</div></div></a></div><div class="next-post pull-right"><a href="/2023/01/18/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Go%E8%AF%AD%E8%A8%80%E5%8D%8F%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B/" title="进程、线程、协程区别"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">进程、线程、协程区别</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">issac</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/issac2e"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/issac2e" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:issac2e@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">哈哈哈哈哈哈哈哈</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81io%E6%A8%A1%E5%9E%8B-socket%E4%BB%8B%E7%BB%8D-%E4%B8%BA%E5%95%A5%E4%BC%9A%E9%98%BB%E5%A1%9E"><span class="toc-text">一、io模型 socket介绍 为啥会阻塞</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BD%91%E7%BB%9C-I-x2F-O-%E4%BC%9A%E8%A2%AB%E9%98%BB%E5%A1%9E%EF%BC%9F"><span class="toc-text">1、为什么网络 I&#x2F;O 会被阻塞？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81I-x2F-O%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">2、I&#x2F;O到底是什么?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%A3%E4%B8%BA%E4%BB%80%E4%B9%88%E9%83%BD%E8%A6%81%E8%B7%9F%E5%86%85%E5%AD%98%E4%BA%A4%E4%BA%92%E5%91%A2"><span class="toc-text">那为什么都要跟内存交互呢?</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E5%88%9B%E5%BB%BA-socket"><span class="toc-text">3、创建 socket</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81bind"><span class="toc-text">4、bind</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81listen"><span class="toc-text">5、listen</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E4%B8%8B%E4%BB%80%E4%B9%88%E5%8F%AB%E5%8D%8A%E8%BF%9E%E6%8E%A5"><span class="toc-text">解释下什么叫半连接</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81accept"><span class="toc-text">6、accept</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81connect"><span class="toc-text">7、connect</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81read%E3%80%81write"><span class="toc-text">8、read、write</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BD%91%E7%BB%9C-I-x2F-O-%E4%BC%9A%E8%A2%AB%E9%98%BB%E5%A1%9E%EF%BC%9F"><span class="toc-text">9、为什么网络 I&#x2F;O 会被阻塞？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E9%80%9A%E9%80%8FIO%E6%A8%A1%E5%9E%8B"><span class="toc-text">二、通透IO模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E5%86%85%E6%A0%B8%E6%80%81%E5%92%8C%E7%94%A8%E6%88%B7%E6%80%81"><span class="toc-text">1、内核态和用户态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9E-I-x2F-O"><span class="toc-text">2、同步阻塞 I&#x2F;O</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E5%90%8C%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9E-I-x2F-O"><span class="toc-text">3、同步非阻塞 I&#x2F;O</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81I-x2F-O-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-text">4、I&#x2F;O 多路复用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8%E5%BC%8FI-x2F-O"><span class="toc-text">5、信号驱动式I&#x2F;O</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E5%BC%82%E6%AD%A5-I-x2F-O"><span class="toc-text">6、异步 I&#x2F;O</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BF%98%E6%98%AFI-x2F-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E5%BC%82%E6%AD%A5I-x2F-O%EF%BC%9F"><span class="toc-text">7、为什么常用的还是I&#x2F;O多路复用，而不是异步I&#x2F;O？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%90%9E%E6%87%82-select-poll-epoll"><span class="toc-text">三、搞懂 select_poll_epoll</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E6%88%91%E4%BB%AC%E6%8B%BF-select-%E7%9A%84%E9%80%BB%E8%BE%91%E6%9D%A5%E5%88%86%E6%9E%90%E4%B8%8B"><span class="toc-text">1、我们拿 select 的逻辑来分析下</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81poll"><span class="toc-text">2、poll</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81epoll"><span class="toc-text">3、epoll</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81ET-lt"><span class="toc-text">4、ET&lt;</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%90%8C%E6%AD%A5%E3%80%81%E5%BC%82%E6%AD%A5%E3%80%81%E9%98%BB%E5%A1%9E%E3%80%81%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="toc-text">四、同步、异步、阻塞、非阻塞</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E5%90%8C%E6%AD%A5-amp-%E5%BC%82%E6%AD%A5"><span class="toc-text">1、同步&amp;异步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E9%98%BB%E5%A1%9E-amp-%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="toc-text">2、阻塞&amp;非阻塞</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81cpu%E6%97%B6%E9%97%B4%E7%89%87%EF%BC%9A"><span class="toc-text">3、cpu时间片：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E5%86%8D%E7%BB%93%E5%90%88-I-x2F-O-%E6%9D%A5%E7%9C%8B"><span class="toc-text">4、再结合 I&#x2F;O 来看</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%B9%B2%E7%BF%BBNetty-%E5%86%99%E4%B8%80%E4%B8%AA%E5%BA%95%E5%B1%82%E9%80%9A%E4%BF%A1%E6%A1%86%E6%9E%B6%E9%9C%80%E8%A6%81%E8%80%83%E8%99%91%E5%93%AA%E4%BA%9B"><span class="toc-text">五、干翻Netty 写一个底层通信框架需要考虑哪些</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88Netty%E4%BD%BF%E7%94%A8NIO%EF%BC%8C%E8%80%8C%E4%B8%8D%E4%BD%BF%E7%94%A8AIO"><span class="toc-text">1、为什么Netty使用NIO，而不使用AIO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#NIO%E5%92%8CAIO%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">NIO和AIO的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#NIO%E6%A8%A1%E5%9E%8B%EF%BC%88%E5%90%8C%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="toc-text">NIO模型（同步非阻塞)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AIO%E6%A8%A1%E5%9E%8B-%E5%BC%82%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9E%EF%BC%89"><span class="toc-text">AIO模型 (异步非阻塞）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E5%86%99%E4%B8%80%E4%B8%AA%E5%BA%95%E5%B1%82%E9%80%9A%E4%BF%A1%E6%A1%86%E6%9E%B6%E9%9C%80%E8%A6%81%E8%80%83%E8%99%91%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">2、写一个底层通信框架需要考虑哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFNetty%EF%BC%9F"><span class="toc-text">3、什么是Netty？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%83%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E6%B5%81%E8%A1%8C%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%A4%9A%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%83%BD%E5%9C%A8%E5%AE%83%E4%B9%8B%E4%B8%8A%E6%9E%84%E5%BB%BA%EF%BC%9F"><span class="toc-text">它为什么这么流行？为什么这么多中间件都在它之上构建？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%93%E7%94%A8"><span class="toc-text">易用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%83%BD"><span class="toc-text">性能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E6%80%A7"><span class="toc-text">扩展性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85"><span class="toc-text">4、什么是粘包拆包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E4%BB%80%E4%B9%88%E6%98%AF%E7%B2%98%E5%8C%85-x2F-%E6%8B%86%E5%8C%85"><span class="toc-text">4.1 什么是粘包&#x2F;拆包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-TCP%E7%B2%98%E5%8C%85-x2F-%E6%8B%86%E5%8C%85%E5%8F%91%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-text">4.2 TCP粘包&#x2F;拆包发生的原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-text">4.3 粘包拆包问题解决方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-%E4%B8%BA%E4%BB%80%E4%B9%88UDP%E4%B8%8D%E4%BC%9A%E5%8F%91%E7%94%9F%E7%B2%98%E5%8C%85-x2F-%E6%8B%86%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-text">4.4 为什么UDP不会发生粘包&#x2F;拆包问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5netty%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85%E9%97%AE%E9%A2%98%E7%9A%84"><span class="toc-text">4.5netty是如何解决粘包拆包问题的</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/17/UofG/itProject_Python/" title="itProject_Python">itProject_Python</a><time datetime="2023-03-17T22:02:08.000Z" title="Created 2023-03-17 22:02:08">2023-03-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/02/14/UofG/Software%20Engineering/" title="Software Engineering">Software Engineering</a><time datetime="2023-02-14T22:02:08.000Z" title="Created 2023-02-14 22:02:08">2023-02-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/02/11/UofG/Advanced%20Programming/" title="Advanced Programming">Advanced Programming</a><time datetime="2023-02-11T22:02:08.000Z" title="Created 2023-02-11 22:02:08">2023-02-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/02/06/Redis/Redis%20%E9%9B%AA%E5%B4%A9%E3%80%81%E5%87%BB%E7%A9%BF%E3%80%81%E7%A9%BF%E9%80%8F%E3%80%81%E9%A2%84%E7%83%AD%E3%80%81%E9%99%8D%E7%BA%A7/" title="Redis 雪崩、击穿、穿透、预热、降级">Redis 雪崩、击穿、穿透、预热、降级</a><time datetime="2023-02-06T22:36:08.000Z" title="Created 2023-02-06 22:36:08">2023-02-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/02/01/UofG/cardGame/" title="Card Game流程梳理">Card Game流程梳理</a><time datetime="2023-02-01T22:02:08.000Z" title="Created 2023-02-01 22:02:08">2023-02-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By issac</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>