<!DOCTYPE html><html lang="zh_CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>Mysql字典，便于梳理知识点 | 每天进步一点点</title><meta name="author" content="issac"><meta name="copyright" content="issac"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1、执行过程 tomcat容器接受客户端请求,请求线程将执行sql交给客户端连接池,发送sql给服务端连接池 服务端连接池接受到连接请求后交给后台线程执行 连接器 校验客户端的权限,比如用户账号密码是否正确,对应的库的操作权限,表的操作权限   查询缓存 执行sql语句的时,先判断查询缓存中是否存在"><link rel="shortcut icon" href="/img/kid.png"><link rel="canonical" href="https://issac2e.github.io/2022/12/06/mysql/mysql%E5%AD%97%E5%85%B8/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Mysql字典，便于梳理知识点',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-02-08 05:47:15'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">16</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">7</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/./img/preview5.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="每天进步一点点"><span class="site-name">每天进步一点点</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Mysql字典，便于梳理知识点</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-12-06T12:32:01.000Z" title="Created 2022-12-06 12:32:01">2022-12-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-02-08T05:47:15.098Z" title="Updated 2023-02-08 05:47:15">2023-02-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Mysql/">Mysql</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Mysql字典，便于梳理知识点"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="1、执行过程"><a href="#1、执行过程" class="headerlink" title="1、执行过程"></a>1、执行过程</h1><ol>
<li>tomcat容器接受客户端请求,<strong>请求线程将执行sql交给客户端连接池,发送sql给服务端连接池</strong></li>
<li>服务端连接池接受到连接请求后<strong>交给后台线程执行</strong></li>
<li><strong>连接器</strong><ul>
<li>校验客户端的权限,比如用户账号密码是否正确,对应的库的操作权限,表的操作权限</li>
</ul>
</li>
<li><strong>查询缓存</strong><ul>
<li>执行sql语句的时,先判断查询缓存中<strong>是否存在相同的sql语句</strong>,存在直接返回结果(适合更新少的情况),缓存中以key-value的方式存储,<strong>key代表sql语句  value代表结果</strong></li>
</ul>
</li>
<li><strong>分析器</strong><ul>
<li>词法分析:分析出字符串分表是什么代表的什么,比如 <code>select * from T where ID=1 </code>得到select代表查询语句,T代表表名,ID代表字段</li>
<li>语法分析:分析使用的关键词名称是否正确:比如select写成 elect,where写成 here;会提示:<code>You have an error in your SQL syntax</code></li>
</ul>
</li>
<li><strong>优化器</strong><ul>
<li>表扫描方式,索引选择,驱动表和被驱动表等</li>
</ul>
</li>
<li><strong>执行器</strong><ul>
<li>先判断用户对当前表操作是否有权限</li>
<li>调用存储引擎来执行sql</li>
</ul>
</li>
</ol>
<h3 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h3><p><img src="/images/WEBc955211ba9144743c6ec179ec9be33b6.octet-stream" alt="image-20200712102528190"></p>
<h1 id="2、redo-log、undo-log、binlog"><a href="#2、redo-log、undo-log、binlog" class="headerlink" title="2、redo log、undo log、binlog"></a>2、redo log、undo log、binlog</h1><h3 id="一条SQL更新语句是如何执行的"><a href="#一条SQL更新语句是如何执行的" class="headerlink" title="一条SQL更新语句是如何执行的?"></a>一条SQL更新语句是如何执行的?</h3><ol>
<li>先判断当前更新数据对于的数据页是否在<strong>innodb buffer</strong>中存在,不存在则加载数据页到缓存页中</li>
<li>写数据的旧值到<strong>undo log</strong>(事务回滚)</li>
<li>更新<strong>innodb buffer</strong>缓存页中数据</li>
<li>写<strong>redo log</strong>到<strong>redo log buffer</strong>中</li>
<li><strong><font color="#0000dd">回滚事务</font></strong>:通过<strong>undo log</strong>重做缓存页中数据</li>
<li><strong><font color="#0000dd">提交事务</font></strong>:<strong>两阶段提交</strong><ul>
<li>将<strong>redo log buffer</strong>中数据刷新到磁盘中</li>
<li><strong>binlog</strong>写入到磁盘中</li>
<li>将<strong>redo log</strong> 标记为commit</li>
</ul>
</li>
</ol>
<h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><ol>
<li><p><strong>物理日志</strong>:记录的是在某个数据页<strong>修改了</strong>什么内容<strong>存储在innodb存储引擎中</strong></p>
</li>
<li><p><strong>格式</strong>:日志类型+表空间+数据页号+偏移量+修改几个字节的值+具体的值</p>
</li>
<li><p><strong>初始化</strong>:</p>
<ul>
<li><p>每个<strong>redo log</strong> 48M    参数:<strong>Innodb_log_file_size</strong></p>
</li>
<li><p><strong>redo log文件</strong>默认两个ib_logfile0和ib_logfile1   参数: <strong>Innodb_log_file_in_group:2</strong></p>
</li>
<li><p><strong>redo log buffer</strong>的大小默认16M    参数:<strong>innodb_log_buffer_size</strong></p>
</li>
<li><p>redo log buffer由多个512b <strong>redo log block</strong>组成</p>
</li>
</ul>
</li>
<li><p><strong>redo log block刷盘时机</strong></p>
<ul>
<li>redo log buffer中写入的redo log占用了redo log buffer一半 8M</li>
<li>一个事务提交时将事务对应的<strong>一个或多个redo log block</strong>刷入到<strong>os cache或磁盘</strong></li>
<li>后台线程每隔1s刷新一次</li>
<li>mysql关闭</li>
</ul>
</li>
<li><p>提交事务redo log<strong>刷盘策略</strong>:<strong>innodb_flush_log_at_trx_commit</strong></p>
<ul>
<li>0:不将redo log buffer数据刷入到磁盘</li>
<li>1:必须将redo log buffer刷入到磁盘</li>
<li>2:刷入到os cache后每隔1s在刷入到磁盘</li>
</ul>
</li>
</ol>
<h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h3><ol>
<li><p>作用:当<strong>事务回滚时</strong>通过undo log来<strong>重做缓存页和数据页的内容</strong></p>
</li>
<li><p>格式</p>
<p><img src="/images/WEB95adebb8fd7c1a396a06d1ab244f6503.octet-stream" alt="image-20200625175929294"></p>
</li>
</ol>
<h3 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h3><h4 id="1、逻辑日志-binlog格式-show-variables-like-“-binlog-format”-默认是row。"><a href="#1、逻辑日志-binlog格式-show-variables-like-“-binlog-format”-默认是row。" class="headerlink" title="1、逻辑日志 binlog格式:show variables like “%binlog_format” ,默认是row。"></a>1、逻辑日志 <strong>binlog格式</strong>:show variables like “%binlog_format” ,<strong>默认是row。</strong></h4><ul>
<li><strong>row:存储的是每一行前后的数据</strong>    <strong><font color="#dd0000">说人话：记录的是每行实际数据的变更</font></strong><ul>
<li>优点:不会出现主从同步mysql 版本导致sql不支持的问题 </li>
<li>缺点:存储数据空间增大</li>
</ul>
</li>
<li><strong>statement:存储执行的sql语句,记录事务id</strong>  <strong><font color="#dd0000">说人话：记录的是修改SQL语句</font></strong><ul>
<li>缺点:主从同步可能<strong>binlog顺序不一致性导致数据丢失</strong></li>
</ul>
</li>
<li><strong>mixed:  statement和row模式的混合</strong></li>
</ul>
<p><strong><font color="#0000dd">以下内容转载自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/rjzheng/p/10510174.html">https://www.cnblogs.com/rjzheng/p/10510174.html</a></font></strong></p>
<p><em><strong>那Mysql在5.0这个版本以前，binlog只支持<code>STATEMENT</code>这种格式！而这种格式在读已提交(Read Commited)这个隔离级别下主从复制是有bug的，因此Mysql将可重复读(Repeatable Read)作为默认的隔离级别！</strong></em></p>
<p><strong><font color="#0000dd">当binlog为<code>STATEMENT</code>格式，且隔离级别为读已提交(Read Commited)时，有什么bug呢？</font></strong></p>
<p>在主(master)上执行如下事务:</p>
<img src="/images/Snipaste_2023-02-07_19-50-40.png" alt="binlog" style="zoom: 67%;" />

<p>此时在主(master)上执行下列语句<code>select * from test；</code></p>
<p>输出如下</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">+---+</span></span><br><span class="line"><span class="section">| b |</span></span><br><span class="line"><span class="section">+---+</span></span><br><span class="line"><span class="section">| 3 |</span></span><br><span class="line"><span class="section">+---+</span></span><br><span class="line">1 row in set</span><br></pre></td></tr></table></figure>

<p>但是，你在此时在从(slave)上执行该语句，得出输出如下</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span></span><br></pre></td></tr></table></figure>

<p>这样，你就出现了**<font color="#0000dd">主从不一致性</font><strong>的问题！原因其实很简单，就是</strong>在master上执行的顺序为先删后插！<strong>而此时</strong>binlog为STATEMENT格式，记录的是修改SQL语句<strong>，它记录的顺序为先插后删！从(slave)同步的是binlog，因此</strong>从机执行的顺序和主机不一致！**就会出现主从不一致！</p>
<h5 id="如何解决主从不一致问题？"><a href="#如何解决主从不一致问题？" class="headerlink" title="如何解决主从不一致问题？"></a><em><strong><font color="#dd0000">如何解决主从不一致问题？</font></strong></em></h5><p>解决方案有两种！<br>(1)隔离级别设为<strong>可重复读(Repeatable Read)</strong>,在该隔离级别下引入**<font color="#006600">间隙锁</font><strong>。当<code>Session 1</code>执行delete语句时，会锁住间隙。那么，<code>Ssession 2</code>执行</strong>插入语句就会阻塞住<strong>！<br>(2)<strong>将binlog的格式修改为row格式</strong>，此时是基于行的复制，自然就</strong>不会出现sql执行顺序不一样的问题！<strong>奈何这个格式在mysql5.1版本开始才引入。因此由于历史原因，mysql将默认的隔离级别设为</strong>可重复读(Repeatable Read)**，保证主从复制不出问题！</p>
<p>那么，当我们了解完mysql选**可重复读(Repeatable Read)<strong>作为默认隔离级别的原因后，接下来我们将其和</strong>读已提交(Read Commited)<strong>进行对比，来说明为什么在互联网项目为什么将隔离级别设为</strong>读已提交(Read Commited)**！</p>
<h5 id="RR-和-RC-对比"><a href="#RR-和-RC-对比" class="headerlink" title="RR 和 RC 对比"></a>RR 和 RC 对比</h5><p>ok，我们先明白一点！项目中是不用**读未提交(Read UnCommitted)<strong>和</strong>串行化(Serializable)**两个隔离级别，原因有二</p>
<ul>
<li>采用<strong>读未提交(Read UnCommitted)</strong>,一个事务读到另一个事务未提交读数据，这个不用多说吧，从逻辑上都说不过去！</li>
<li>采用<strong>串行化(Serializable)<strong>，每个次读操作都会加锁，快照读失效，一般是</strong>使用mysql自带分布式事务功能时才使用该隔离级别！</strong>(因为<strong>这是XA事务，是强一致性事务，性能不佳！</strong>互联网的分布式方案，<strong>多采用最终一致性的事务解决方案</strong>！)</li>
</ul>
<p>也就是说，我们该纠结都只有一个问题，究竟隔离级别是用读已经提交呢还是可重复读？<br>接下来对这两种级别进行对比，<strong>讲讲我们为什么选读已提交(Read Commited)作为事务隔离级别！</strong><br>假设表结构如下</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `test` (</span><br><span class="line">`id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`color` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB</span><br></pre></td></tr></table></figure>

<p>数据如下</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">+----+</span>-------+</span><br><span class="line"><span class="section">| id | color |</span></span><br><span class="line"><span class="section">+----+-------+</span></span><br><span class="line">|  1 |  red  |</span><br><span class="line">|  2 | white |</span><br><span class="line">|  5 |  red  |</span><br><span class="line"><span class="section">|  7 | white |</span></span><br><span class="line"><span class="section">+----+-------+</span></span><br></pre></td></tr></table></figure>

<p><strong><font color="#dd0000">缘由一：在RR隔离级别下，存在间隙锁，导致出现死锁的几率比RC大的多！</font></strong><br>此时执行语句 <code>select * from test where id &lt;3 for update;</code></p>
<p><strong><font color="#0000dd">在RR隔离级别下，存在间隙锁，可以锁住(2,5)这个间隙，防止其他事务插入数据！</font></strong><br><strong><font color="#0000dd">而在RC隔离级别下，不存在间隙锁，其他事务是可以插入数据！</font></strong></p>
<p>PS :在RC隔离级别下并不是不会出现死锁，只是出现几率比RR低而已！</p>
<p><strong><font color="#dd0000">缘由二：在RR隔离级别下，条件列未命中索引会锁表！而在RC隔离级别下，只锁行</font></strong><br>此时执行语句<code>update test set color = &#39;blue&#39; where color = &#39;red&#39;; </code></p>
<p><strong>在RC隔离级别下，其先走聚簇索引，进行全部扫描。</strong>加锁如下：</p>
<img src="/images/Snipaste_2023-02-07_20-12-04.png" alt="加锁" style="zoom: 50%;" />

<p>但在实际中，MySQL做了优化，在MySQL Server过滤条件，<strong>发现不满足后，会调用unlock_row方法，把不满足条件的记录放锁。</strong>加锁如下：</p>
<img src="/images/Snipaste_2023-02-07_20-23-57.png" alt="加锁1" style="zoom:50%;" />

<p>然而，在RR隔离级别下，走聚簇索引，进行全部扫描，<strong>最后会将整个表锁上</strong></p>
<img src="/images/Snipaste_2023-02-07_20-24-53.png" alt="加锁3" style="zoom:50%;" />

<p><strong><font color="#dd0000">缘由三：在RC隔离级别下，半一致性读(semi-consistent)特性增加了update操作的并发性！</font></strong><br>在5.1.15的时候，innodb引入了一个概念叫做“<strong>semi-consistent</strong>”，<strong>减少了更新同一行记录时的冲突，减少锁等待</strong>。<br>所谓半一致性读就是，一个update语句，如果<strong>读到一行已经加锁的记录</strong>，此时<strong>InnoDB返回记录最近提交的版本</strong>，由MySQL上层判断此版本<strong>是否满足update的where条件</strong>。若满足(需要更新)，则<strong>MySQL会重新发起一次读操作，此时会读取行的最新版本(并加锁)！</strong><br>具体表现如下:  此时有两个Session，Session1 和 Session2 ！<br>Session1 执行<code>update test set color = &#39;blue&#39; where color = &#39;red&#39;; </code></p>
<p><strong>先不Commit事务！</strong> 与此同时 Ssession2 执行<code>update test set color = &#39;blue&#39; where color = &#39;white&#39;; </code></p>
<p>session 2尝试加锁的时候，发现行上已经存在锁，<strong>InnoDB会开启semi-consistent read，返回最新的committed版本</strong> (1,red),(2，white),(5,red),(7,white)。**<font color="#0000dd">MySQL会重新发起一次读操作</font>，此时会读取行的最新版本(并加锁)!**<br>而在RR隔离级别下，Session2只能等待！</p>
<h3 id="两个疑问"><a href="#两个疑问" class="headerlink" title="两个疑问"></a>两个疑问</h3><p><em><strong><font color="#006600">在RC级别下，不可重复读问题需要解决么？</font></strong></em><br>不用解决，这个问题是可以接受的！毕竟你数据都已经提交了，读出来本身就没有太大问题！Oracle的默认隔离级别就是RC，你们改过Oracle的默认隔离级别么？</p>
<p><em><strong><font color="#006600">在RC级别下，主从复制用什么binlog格式？</font></strong></em><br><strong>该隔离级别下，用的binlog为row格式，是基于行的复制！Innodb的创始人也是建议binlog使用该格式！</strong></p>
<h4 id="2、查看binlog方式"><a href="#2、查看binlog方式" class="headerlink" title="2、查看binlog方式**"></a>2、查看binlog方式**</h4><ul>
<li>目录:<code>show VARIABLES like &#39;%datadir%&#39;</code></li>
<li>配置:<code>show VARIABLES like &#39;%log_bin%&#39;</code></li>
<li>列表:<code>show BINARY logs</code></li>
<li>指定binlog文件:<code>show BINLOG EVENTS in &quot;binlog.000001&quot;</code></li>
<li>指定position查看:<code>mysqlbinlog --start-position=382979319  mysql-bin.002578 | more</code></li>
</ul>
<h4 id="3、刷盘策略-sync-binlog"><a href="#3、刷盘策略-sync-binlog" class="headerlink" title="3、刷盘策略:sync_binlog"></a>3、刷盘策略:sync_binlog</h4><ul>
<li>0: binlog写入到os cache中每隔1s在刷入到磁盘中</li>
<li>1: 强制将bin log刷入到磁盘中</li>
<li>N: 表示每次事物提交write,当write事物超过n个时fsync</li>
</ul>
<h3 id="redo-log两阶段提交"><a href="#redo-log两阶段提交" class="headerlink" title="redo log两阶段提交"></a>redo log两阶段提交</h3><h4 id="执行原理"><a href="#执行原理" class="headerlink" title="执行原理"></a><strong>执行原理</strong></h4><ul>
<li>执行器<strong>询问存储引擎是否可提交事务</strong>,存储引擎将redo log标记为<strong>prepare commit返回server端</strong>可提交事务</li>
<li>server端<strong>写binlog归档日志</strong></li>
<li>执行器调用<strong>存储引擎commit接口</strong>,存储引擎将redo log标记为commit</li>
</ul>
<h4 id="存在情况"><a href="#存在情况" class="headerlink" title="存在情况"></a><strong>存在情况</strong></h4><ul>
<li><strong>当redo日志prepare commit失败时</strong>,此时<strong>直接失败</strong>  master和slave数据保持一致</li>
<li><strong>写入redo日志成功,写入binlog日志失败</strong>,此时master和slave保持一致**,binlog日志写入失败后redo日志回滚**</li>
<li><strong>写入redo成功,binlog成功,commit失败</strong>  此时master和slave短暂不一致,<strong>master重启的时候由于redo和binlog中都存在会强行将redo中日志改为commit</strong></li>
</ul>
<h3 id="更新数据原理图"><a href="#更新数据原理图" class="headerlink" title="更新数据原理图"></a>更新数据原理图</h3><p><img src="/images/WEBf87dd85ec73a78df2bc434789b5fb6ca.octet-stream" alt="image-20200625163352136"></p>
<h1 id="3、innodb-buffer（TODO）"><a href="#3、innodb-buffer（TODO）" class="headerlink" title="3、innodb buffer（TODO）"></a>3、innodb buffer（TODO）</h1><h3 id="innodb-buffer"><a href="#innodb-buffer" class="headerlink" title="innodb buffer"></a>innodb buffer</h3><ol>
<li><strong>缓冲池</strong>:提前分配好固定大小,每个缓存页 16K和描述数据</li>
<li><strong>描述数据</strong>:表空间+缓存页的标识符,大小为缓存页的5% 16*5%&#x3D;800b</li>
</ol>
<h3 id="free链表"><a href="#free链表" class="headerlink" title="free链表"></a>free链表</h3><ol>
<li><strong>组成</strong>:空闲缓存页的描述数据组成的<strong>双向链表</strong>,基础节点连接链表头和尾</li>
<li>**作用:**当数据页从磁盘加载到缓存页时,从free链表获取节点,在根据节点中缓存页标识符找到对应的缓存页加载数据页到缓存页中,删除free链表中描述数据节点</li>
</ol>
<h3 id="flush链表"><a href="#flush链表" class="headerlink" title="flush链表"></a>flush链表</h3><ol>
<li><strong>组成</strong>:记录被修改的缓存页的描述数据节点,双向链表,基础节点连接链表头和尾</li>
<li><strong>作用</strong>:记录哪些缓存页的数据被修改了没刷新到磁盘中即脏页的数据</li>
</ol>
<h3 id="lru链表"><a href="#lru链表" class="headerlink" title="lru链表"></a>lru链表</h3><ol>
<li>组成:记录使用缓存页的描述数据节点,双向链表,基础节点连接链表头和尾</li>
<li>作用:当free链表中没有当前表空间对应的描述数据节点时需要淘汰缓存页</li>
<li>局部性原理:当我们读取一个sql的时候很可能去读取他的下一个数据页则提前预处理读取加载到缓冲区中</li>
<li><strong>lru缓存优化</strong>:<ul>
<li>普通lru<ul>
<li>最近最少使用的<strong>在尾部淘汰,存在问题</strong></li>
<li>当缓存页进行预读时,很容易将无效缓存页读取到lru链表中,导致有效缓存页被淘汰</li>
</ul>
</li>
<li>改进lru<ul>
<li>热数据和冷数据 7:3</li>
<li>当数据页加载到缓存页时,加入到冷数据头部,在1s内被访问时放入到热数据头部</li>
<li>热数据前3&#x2F;4部分内容被访问时不进行移动</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="缓存页hash表"><a href="#缓存页hash表" class="headerlink" title="缓存页hash表"></a>缓存页hash表</h3><ol>
<li>作用:判断当前数据页的数据是否在缓存页中存在,存在则直接修改缓存页数据不存在则从磁盘读取数据页在加载到缓存页中</li>
<li>key:表空间id+数据页号 value:缓存页地址</li>
</ol>
<h3 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h3><ol>
<li>定时任务刷新lru冷数据尾部到磁盘,同时删除flush链表和lru链表节点,释放到free链表</li>
<li>定时任务刷新flush链表到磁盘,删除flush链表和lru链表节点,释放到free链表</li>
</ol>
<h3 id="innodb参数"><a href="#innodb参数" class="headerlink" title="innodb参数"></a>innodb参数</h3><ol>
<li><p>innodb buffer配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">innodb_buffer_pool_size #缓冲池大小</span><br><span class="line">innodb_old_blocks_pct #lru新生代和老年代比率 默认7:3</span><br><span class="line">innodb_old_blocks_time #老年代停留时间窗口 单位毫秒默认为1000</span><br><span class="line">innodb_buffer_pool_instance #buffer pool的实例个数</span><br><span class="line">buffer_pool_size = (128Mchunk个数*instance个数)*2倍 要大于2倍</span><br></pre></td></tr></table></figure>
</li>
<li><p>innodb buffer结果:show engine innodb status</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># 分配给innodb buffer最终大小</span><br><span class="line">Total large memory allocated 137428992</span><br><span class="line">Dictionary memory allocated 1129839</span><br><span class="line"># buffer pool中容纳多少个缓存页</span><br><span class="line">Buffer pool size   8192</span><br><span class="line"># free 链表中空闲的缓存页</span><br><span class="line">Free buffers       6753</span><br><span class="line"># lru中一共有多少个缓存页</span><br><span class="line">Database pages     1432</span><br><span class="line"># lru老年代中缓存页数量</span><br><span class="line">Old database pages 508</span><br><span class="line"># flush链表中缓存页数量</span><br><span class="line">Modified db pages  0</span><br><span class="line"># 准备从磁盘中读取到缓存页的数量</span><br><span class="line">Pending reads      0</span><br><span class="line"># 准备刷新lru 老年代数据到磁盘中缓存页数量和flush链表刷新缓存页到磁盘数量</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line"># 从老年代到新生代缓存页的数量;1s内被访问了未进入新生代缓存页的数量</span><br><span class="line">Pages made young 388, not young 82</span><br><span class="line"># 每秒老年代数据进入新生代数据的比率 每秒数据在老年代被访问了但是不能进入新生代的比率</span><br><span class="line">0.00 youngs/s, 0.00 non-youngs/s</span><br><span class="line"># 读取缓存页 创建缓存页 写入的缓存页</span><br><span class="line">Pages read 597, created 1253, written 24609</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">No buffer pool page gets since the last printout</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 1432, unzip_LRU len: 0</span><br><span class="line">I/O sum[0]:cur[0], unzip sum[0]:cur[0]</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="4、数据页和索引页"><a href="#4、数据页和索引页" class="headerlink" title="4、数据页和索引页"></a>4、数据页和索引页</h1><h3 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h3><ol>
<li>每个表对应一个表空间,在磁盘中存储为<strong>表.ibd</strong></li>
<li>extent:一个数据区对应<strong>64个连续的数据页</strong>,每个数据页是<strong>16k</strong>  extent即:1M</li>
<li>一个数据区组:由<strong>256个数据区</strong>组成</li>
<li>表空间的第一组数据组的第一个数组区的前3个页存储表空间和当前这一组数据的属性</li>
</ol>
<h3 id="数据页"><a href="#数据页" class="headerlink" title="数据页"></a>数据页</h3><ol>
<li>数据页大小<strong>16KB</strong>,包含多个数据行</li>
<li>数据行存储<ol>
<li>可变长度列表 逆序存储</li>
<li>为空列表 逆序存储</li>
<li>40位bit<ul>
<li>1和2预留</li>
<li>delete_mask:标识这行数据是否删除</li>
<li>min_rec_mask:b+树中每一层的非叶子节点的最小值标记</li>
<li>n_owned:记录数 4个bit</li>
<li>heap_no:13个bit 这行数据在堆中的位置</li>
<li>record_type:3个bit 行数据的类型<ul>
<li>0:普通类型</li>
<li>1:B+树非叶子节点</li>
<li>2:最小值</li>
<li>3:最大值</li>
</ul>
</li>
<li>next_record:16bit 指向下一条数据的指针</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="数据行存储示例"><a href="#数据行存储示例" class="headerlink" title="数据行存储示例"></a>数据行存储示例</h3><ol>
<li><p>表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table <span class="title function_">customer</span><span class="params">(</span></span><br><span class="line"><span class="params"> name varchar(<span class="number">10</span>)</span> not <span class="literal">null</span>,</span><br><span class="line"> address <span class="title function_">varchar</span><span class="params">(<span class="number">20</span>)</span>,</span><br><span class="line"> gender <span class="title function_">char</span><span class="params">(<span class="number">1</span>)</span>,</span><br><span class="line"> job <span class="title function_">varchar</span><span class="params">(<span class="number">30</span>)</span>,</span><br><span class="line"> school <span class="title function_">varchar</span><span class="params">(<span class="number">50</span>)</span></span><br><span class="line">) row_format=Compact;</span><br></pre></td></tr></table></figure>
</li>
<li><p>存储数据格式:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数据:jack <span class="literal">null</span> m <span class="literal">null</span> xx_school</span><br><span class="line">存储:<span class="number">0x09</span> <span class="number">0x04</span> <span class="number">00000101</span> <span class="number">000000000000000000000000000000</span> jack m xx_school</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据查询方式:</p>
<ul>
<li>name:不为空 可变长度去可变长度列表查询0x04代表4个子节读取到jack</li>
<li>address:可为空 可变长度,先判断为空列表标志位:1 为空 则不获取</li>
<li>gender:可为空 固定长度,为空列表标志位0 不为空 则获取1个字符 读取到m</li>
<li>job:可为空 可变长度,为空列表标志位1 为空则获取</li>
<li>school:可为空,为空列表标志位0 不为空则获取<strong>可变长度列表为0x09</strong> 读取9个子节点 xx_school</li>
</ul>
</li>
</ol>
<h3 id="常见的索引模型"><a href="#常见的索引模型" class="headerlink" title="常见的索引模型"></a>常见的索引模型</h3><ol>
<li><h5 id="hash索引"><a href="#hash索引" class="headerlink" title="hash索引"></a>hash索引</h5><ul>
<li><p><strong>原理</strong>:key-value的方式存储,比如name:张三,通过hash后O(1)定位到数据</p>
</li>
<li><p><strong>存在问题</strong>:当<strong>多个数据hash得到的结果一样的时候</strong>,此时需要在hash对应的数组下方<strong>挂一个链表</strong>,查询和删除的时间<strong>复杂度增加</strong>;不适合<strong>范围内的数据查询</strong></p>
</li>
<li><p><strong>适用场景</strong>:比如身份证号,永远<strong>不会重复的数据</strong>,进行数据的<strong>等值查询</strong>;在mysql中有自适应hash索引</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/LIsaWinLee/article/details/123279068">https://blog.csdn.net/LIsaWinLee/article/details/123279068</a></p>
<p><img src="/images/Snipaste_2023-02-07_19-03-22.png" alt="hash碰撞"></p>
</li>
</ul>
</li>
<li><h5 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h5><ul>
<li>原理:查询时间复杂度O(logn),左边节点小于当前节点,右边节点大于当前节点,通过<strong>中序遍历</strong>可以得到所有结果</li>
<li>存在问题:当插入数据的时候,如果数据<strong>分配在单个左右节点</strong>,导致**树的高度过长,**浪费空间,查询效率不等</li>
<li>使用场景:当数据较少,构建的二叉搜索树较均匀时</li>
</ul>
</li>
<li><h5 id="二叉平衡树"><a href="#二叉平衡树" class="headerlink" title="二叉平衡树"></a>二叉平衡树</h5><ul>
<li>原理:在二叉搜索的树的基础上,保证<strong>叶子节点的高度差不超过1</strong>,当数据插入的时候进行左旋和右旋</li>
<li>存在问题:<strong>当数据量较大的时候,高度也会很高</strong>,在<strong>数据存储时每一页读取的数据有限</strong>,需要<strong>进行大量的磁盘页读取操作</strong></li>
<li>使用场景:数据较少的时候</li>
</ul>
</li>
<li><h5 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h5><ul>
<li><p>原理:在二叉平衡树的基础上降低树的高度,每个节点<strong>存储多个数组</strong>  </p>
<p>比如 第一层:  [3,10]  第二层:左:[1,2]  中间:[4,6,8]  右:[11,12,13]  <strong>降低了数的高度</strong>,此时<strong>叶子节点和非叶子节点都存储数据</strong></p>
</li>
<li><p><strong><font color="#dd0000">存在问题:非叶子节点存储了数据,导致查询的时候筛选出来的数据在叶子节点和非叶子节点都存在,不方便数据的筛选和查询</font></strong></p>
</li>
</ul>
</li>
<li><h5 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h5><ul>
<li>原理:在B树的基础上将非叶子节点的数据下沉,非叶子节点不存在数据,<strong>所有数据存储在叶子节点中</strong>,<strong>叶子节点数据通过链表相连</strong>.非叶子节点即向上抽取的索引区间,跟链表类似</li>
<li>优点:降低了树的高度,进行<strong>搜索的时候方便数据定位O(logn)</strong></li>
</ul>
</li>
</ol>
<h3 id="索引页"><a href="#索引页" class="headerlink" title="索引页"></a>索引页</h3><ol>
<li>b+树<ul>
<li>B+树上每个<strong>非叶子节点存储的是索引页的页号+最小主键值</strong></li>
<li>叶子节点存储的<strong>当前页的数据或多个数据页双向链表</strong></li>
<li>每个数据页<strong>单向链表相连,主键索引维护主键目录</strong></li>
<li><img src="/images/WEB0307eb437578243054c9b104dea974c1.octet-stream" alt="image-20200712085635869"></li>
</ul>
</li>
<li>数据查找过程<ul>
<li>首先<strong>通过主键值在索引页的B+树上查找到对应的索引页</strong></li>
<li><strong>根据索引页找到对应的数据页</strong></li>
<li>在根据<strong>数据页中主键目录找到对应的槽</strong></li>
<li>在根据<strong>槽找到一组指定的数据</strong></li>
<li>在<strong>一组数据上进行二分查找</strong></li>
</ul>
</li>
</ol>
<h3 id="mysql使用不同的索引类型对应的数据存储方式"><a href="#mysql使用不同的索引类型对应的数据存储方式" class="headerlink" title="mysql使用不同的索引类型对应的数据存储方式"></a>mysql使用不同的索引类型对应的数据存储方式</h3><ol>
<li><p>NORMAL   普通索引</p>
</li>
<li><p>FULLTEXT  文本类型的索引目前只有mysql引擎MyISAM(varchar char text)</p>
</li>
<li><p>SPATIAL	空间索引</p>
</li>
<li><p>UNIQUE	唯一索引</p>
</li>
</ol>
<h1 id="5、事务"><a href="#5、事务" class="headerlink" title="5、事务"></a>5、事务</h1><h3 id="事物ACID"><a href="#事物ACID" class="headerlink" title="事物ACID"></a>事物ACID</h3><ol>
<li>原子性:整个事务中的一组操作,要么全部完成,要么全部不完成</li>
<li>一致性:在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏</li>
<li>隔离性:两个事务同时运行互不影响</li>
<li>持久性:在事务完成以后,该事务对数据库变更操作会持久化</li>
</ol>
<h3 id="事物隔离级别"><a href="#事物隔离级别" class="headerlink" title="事物隔离级别"></a>事物隔离级别</h3><ul>
<li><p>读未提交:一个事物可以读取到另外一个事物未提交的数据**,存在脏读**</p>
</li>
<li><p>读已提交:一个事物可以读取到另外一个事物已提交的数据,<strong>存在不可重复读(数据被更新，两次读结果不一致)||oracle,sql server READ-COMMITTED</strong></p>
<p><em><strong><font color="#dd0000">为什么默认的隔离级别都会选用read commited</font> 原因有二：repeatable存在间隙锁会使死锁的概率增大，在RR隔离级别下，条件列未命中索引会锁表！而在RC隔离级别下，只锁行</strong></em></p>
<p><em><strong><font color="#dd0000">在RC级用别下，主从复制用什么binlog格式：</font> row格式，是基于行的复制！</strong></em></p>
</li>
<li><p>可重复读:对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>但幻读仍有可能发生。(幻读:数据被删除或插入，读取到行数据不一致) || mysql  REPEATABLE-READ</strong> </p>
<p><em><strong><font color="#dd0000">为什么mysql默认用的是repeatable而不是read committed:</font>在 5.0之前只有statement一种格式，而主从复制存在了大量的不一致，故选用repeatable</strong></em>。  <strong><font color="#dd0000">当然项目中一般用读已提交(Read Commited)这个隔离级别！</font></strong></p>
<p><strong><font color="#0000dd">mysql binlog的格式三种：statement,row,mixed</font></strong></p>
</li>
<li><p>串行化: 最高的隔离级别，完全服从ACID的隔离级别。<strong>所有的事务依次逐个执行</strong>，这样事务之间就完全不可能产生干 扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。 <strong>加锁, 写:写锁   读:读锁</strong></p>
</li>
</ul>
<h3 id="mvcc和read-view"><a href="#mvcc和read-view" class="headerlink" title="mvcc和read-view"></a>mvcc和read-view</h3><ol>
<li><strong>mvcc多版本控制</strong>:当开启一个事务进行update操作时,会在之前的版本上copy一份新的版本,然后进行数据的修改,<strong>旧数据存储在undo log中</strong>,其他事务<strong>通过最新版本和undo log来读取旧版本数据</strong></li>
<li>read view视图:<ul>
<li>m_ids:活跃事务数组</li>
<li>min_trx_id:活跃事务数组m_ids最小值</li>
<li>max_trx_id:下一个事务id值</li>
<li>creator_trx_id:当前事务id</li>
</ul>
</li>
<li>快照读<ul>
<li>min_trx_id之前的数据可见</li>
<li>在min_trx_id和max_trx_id之间数据,在m_ids存在不可见 不存在可见</li>
<li>大于max_trx_id不可见</li>
<li>结论:版本未提交不可见  版本已提交,如果在当前read-view之前可见,之后不可见</li>
</ul>
</li>
<li>当前读:如果当前版本和当前事物id相等则为当前读</li>
</ol>
<h3 id="RC和RR的快照读区别"><a href="#RC和RR的快照读区别" class="headerlink" title="RC和RR的快照读区别"></a>RC和RR的快照读区别</h3><ol>
<li>RC下每次都会创建一个新的read-view视图</li>
<li>RR下只会创建一个read-view,在当前事物第一次读的时候</li>
</ol>
<h3 id="隔离级别和是否自动提交"><a href="#隔离级别和是否自动提交" class="headerlink" title="隔离级别和是否自动提交"></a>隔离级别和是否自动提交</h3><ol>
<li>查看事务隔离级别:<code>select @@tx_isolation</code></li>
<li>查看当前会话隔离级别:<code>select @@session.tx_isolation</code></li>
<li>设置当前事务隔离级别:<code>set session transaction isolation level read committed;</code></li>
<li>设置全局事务隔离级别:<code>set global transaction isolation level read committed;</code></li>
<li>查询是否自动提交:<code>select @@autocommit  1:自动提交 0:不自动提交</code></li>
<li>设置不自动提交:<code>set autocommit=0</code></li>
</ol>
<h1 id="6、锁"><a href="#6、锁" class="headerlink" title="6、锁"></a>6、锁</h1><h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><ol>
<li><p>概念:将整个库锁住,不能进行写和读操作</p>
</li>
<li><p>命令:<code>flush tables with read lock(FTWRL)</code></p>
<ul>
<li><p>DML语句阻塞 <code>DML（data manipulation language）是数据操纵语言：它们是SELECT、UPDATE、INSERT、DELETE</code></p>
</li>
<li><p>DDL语句阻塞 <code>DDL（data definition language）是数据定义语言：DDL比DML要多，主要的命令有CREATE、ALTER、DROP等，DDL主要是用在定义或改变表（TABLE）的结构，数据类型，表之间的链接和约束等初始化工作上，他们大多在建立表时使用。</code></p>
<p>补充：<code>DCL（DataControlLanguage）是数据库控制语言：是用来设置或更改数据库用户或角色权限的语句，包括（grant,deny,revoke等）语句。</code></p>
</li>
<li><p>事物commit操作阻塞</p>
</li>
</ul>
</li>
<li><p>使用场景:</p>
<ul>
<li>全库逻辑备份,将每个表select查询出来后保存到文件中</li>
<li>在主库上备份,此时实例则不能执行业务</li>
<li><strong>在备库上备份,binlog日志同步延时</strong></li>
</ul>
</li>
<li><p>优化方案:一致性读,此时表需要支持事物的隔离级别</p>
<ul>
<li>single-transaction:在导数据的时候开启一个事物,获取read-view快照,其他操作不影响该视图</li>
</ul>
</li>
</ol>
<h3 id="表锁-TODO不说人话。。"><a href="#表锁-TODO不说人话。。" class="headerlink" title="表锁(TODO不说人话。。)"></a>表锁(TODO不说人话。。)</h3><ol>
<li>表锁<ul>
<li><code>lock tables ... read/write</code>, 通过<code>unlock table...</code>来释放锁.读写不能并行</li>
</ul>
</li>
<li>元数据锁(用来隔离DDL和DML)<ul>
<li>MDL(metadata lock),在访问一个表的时候自动加上</li>
<li>作用:保证读写的正确性,当一个表被获取了MDL读锁后,不能获取MDL写锁</li>
<li>进行DML操作获取MDL读锁,DDL操作获取MDL写锁</li>
<li>对小表添加字段导致整个库宕机的行为分析<ul>
<li>比如session a,b 进行 DML查询操作;此时获取MDL读锁;session c进行 alter操作DDL操作需要获取MDL写锁,此时阻塞.后面的其他session获取MDL的读锁也会被session c阻塞,获取失败创建其他session导致整个数据库宕机</li>
<li>解决长事物的问题,防止前面获取MDL读锁太长时间,导致后续操作阻塞session连接过多;可以通过观察information找到kill掉长事物后在进行DDL操作</li>
<li>设定一定的等待时间去获取MDL的写锁,这个过程中如果有其他MDL读锁获取的操作则获取失败,然后进行重试</li>
</ul>
</li>
</ul>
</li>
<li>online(5.6 优化了表操作的DDL上的MDL情况)<ul>
<li>拿MDL写锁</li>
<li>降级成MDL读锁</li>
<li>真正DDL</li>
<li>升级为MDL写锁</li>
<li>释放MDL锁</li>
</ul>
</li>
</ol>
<h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><ol>
<li><h5 id="临界锁-对某个区间包括本身加锁即gap-record"><a href="#临界锁-对某个区间包括本身加锁即gap-record" class="headerlink" title="临界锁: 对某个区间包括本身加锁即gap+record"></a>临界锁: <strong>对某个区间包括本身加锁</strong>即gap+record</h5></li>
<li><h5 id="间隙锁-gap-lock-锁定一个范围当时不包括本身-间隙锁之前不互斥和插入该间隙的sql互斥"><a href="#间隙锁-gap-lock-锁定一个范围当时不包括本身-间隙锁之前不互斥和插入该间隙的sql互斥" class="headerlink" title="间隙锁: gap-lock 锁定一个范围当时不包括本身,间隙锁之前不互斥和插入该间隙的sql互斥"></a>间隙锁: <del>gap-lock 锁定一个范围当时不包括本身,间隙锁之前不互斥和插入该间隙的sql互斥</del></h5><ul>
<li><strong>对于键值在条件范围内但并不存在的记录叫做“间隙”</strong>，InnoDB也会对这种 “间隙” 加锁，这种锁机制叫做 “间隙锁”。</li>
</ul>
<p><strong>产生原因：</strong></p>
<p>​    间隙锁的出现主要集中在同一个事务中先delete后insert的情况下， 当我们通过一个条件去删除一条已有记录时：</p>
<ul>
<li><strong>如果参数在数据库中存在</strong>，那么这个时候产生的是<strong>普通行锁，锁住这个记录并删除， 然后释放锁。</strong></li>
<li>如果这条记录不存在，问题就来了：数据库会扫描索引，发现这个记录不存在，这时的<strong>delete语句获取到的就是一个间隙锁</strong>。然后数据库会<strong>向左扫描到第一个比给定条件小的值，向右扫描扫描到第一个比给定条件大的值。</strong> 最后以此为界构建一个区间， 锁住整个区间内的数据， 一个特别容易导致死锁的间隙锁诞生了。</li>
</ul>
<p><strong>前提：</strong></p>
<ul>
<li>间隙锁是在<strong>可重复读</strong>隔离级别下才会生效的。所以，你如果把隔离级别设置为<strong>读已提交的话，就没有间隙锁了</strong>。</li>
<li>检索条件必须有<strong>普通索引</strong>（没有索引的话，MySQL会全表扫描，那样会锁定整张表所有的记录，包括不存在的记录，此时其他事务不能修改不能删除不能添加）</li>
</ul>
<blockquote>
<p>不在<strong>主键</strong>和<strong>唯一索引</strong>上用间隙锁是因为这两种记录都是唯一的，不存在间隙，**<font color="#0000dd">但是在范围查询的时候还是会用到间隙锁</font>**</p>
</blockquote>
<p><strong>作用：</strong></p>
<p>​    为了防止出现****幻读 <font color="#006600">(和前面可重复读对应上了，可重复读是有可能发生幻度的)</font>**<strong>（</strong><font color="#dd0000">读到之前不存在的新增记录，或之前存在的记录被其他并发事务删除，导致前后结果集不一致</font>**），但会把锁定范围扩大。</p>
<p><strong>危害：</strong></p>
<p>​    会造成在<strong>锁定时无法插入锁定键值范围内的任何数据（包括不存在的键值）</strong>，在某些场景下可能会对<strong>性能造成很大影响</strong>。</p>
<p><strong>是否开启设置：</strong><br>    在数据库参数中， 控制间隙锁的参数是：innodb_locks_unsafe_for_binlog，这个参数<strong>默认值是OFF， 也就是启用间隙锁， 他是一个bool值， 当值为true时表示disable间隙锁。</strong><br>    那为了防止间隙锁是不是直接将innodb_locaks_unsafe_for_binlog设置为true就可以了呢？ 不一定！而且这个参数会影响到主从复制及灾难恢复， 这个方法还尚待商量。</p>
<p><strong>补充：</strong></p>
<p>​    除了间隙锁以外，还有一种**<font color="#dd0000">next-key锁</font><strong>，</strong><em>next-key锁 &#x3D; 记录锁 + 间隙锁</em><strong>。</strong><font color="#0000dd">即锁定一个范围，并且锁定记录本身</font><strong>，</strong><font color="#dd0000">InnoDB默认加锁方式是 next-key 锁</font>**。</p>
</li>
<li><h5 id="记录锁-record-lock-对某一行记录加锁"><a href="#记录锁-record-lock-对某一行记录加锁" class="headerlink" title="记录锁 record-lock 对某一行记录加锁"></a>记录锁 record-lock 对某一行记录加锁</h5></li>
</ol>
<h3 id="锁分析思路-TODO"><a href="#锁分析思路-TODO" class="headerlink" title="锁分析思路 TODO"></a>锁分析思路 TODO</h3><ul>
<li><p>原则1: 加锁的基本单位为next-key lock,左开右闭</p>
</li>
<li><p>原则2: 查找中访问的对象才加锁</p>
</li>
<li><p>优化1: 索引上的等值查询,给唯一索引时,临界锁降级为行锁 ??????&#x2F;TODO</p>
</li>
<li><p>优化2: 索引上的等值查询,向右遍历且最后一个值不满足等值条件时,锁降级为间隙锁  </p>
</li>
<li><p>bug:唯一索引的范围查询,会访问到第一个不满足条件的位置</p>
</li>
<li><p>注意事项:等值范围查询比如 &gt;&#x3D;时第一个值为&#x3D;等值查询,&gt;范围查询</p>
</li>
</ul>
<h1 id="7、JOIN"><a href="#7、JOIN" class="headerlink" title="7、JOIN"></a>7、JOIN</h1><h3 id="Index-Nested-Loop-Join"><a href="#Index-Nested-Loop-Join" class="headerlink" title="Index Nested-Loop Join"></a>Index Nested-Loop Join</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t2` </span><br><span class="line">( `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>, </span><br><span class="line"> `a` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> `b` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line"> KEY `a` (`a`)) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">create</span> <span class="keyword">table</span> t2 <span class="keyword">like</span> t1;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 straight_join t2 <span class="keyword">on</span> t1.a <span class="operator">=</span> t2.a</span><br></pre></td></tr></table></figure>

<ol>
<li>straight_join: mysql不走优化器指定的驱动表和被驱动表, 此时<strong>t1:驱动表 t2:被驱动表</strong></li>
<li><strong><font color="#dd0000">sql执行流程</font></strong><ul>
<li>从t1表取一行记录,获取行记录中的字段a</li>
<li>根据字段a,在t2表的**普通索引上查询,**找到满足条件数据,<strong>获取二级索引对应的t2.id</strong></li>
<li>根据t2.id<strong>回表查询</strong>t2 行记录,返回结果集</li>
<li>重复以上三个步骤</li>
</ul>
</li>
<li>如果t1和t2对应的数据都是100行,数据等值即t1.a和t2.a一一对应</li>
<li>T1:全表扫描100行,t2:每次通过t1.a,在t2.a索引上找到t2.id,回表查询;t2:总共扫描100行</li>
<li>假设驱动表数据量:N 被驱动表:M   则整个过程时间复杂度近似 <strong>N+N*2lgM</strong>   <strong>2:代表t2.a和t2.id两棵树</strong></li>
<li><strong>显然N对时间复杂度影响较大</strong>,此时join需要**<font color="#0000dd">小表来驱动大表</font>**</li>
</ol>
<h3 id="Simple-Nested-Loop-join"><a href="#Simple-Nested-Loop-join" class="headerlink" title="Simple Nested-Loop join"></a>Simple Nested-Loop join</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 straight_join t2 <span class="keyword">on</span> t1.a <span class="operator">=</span> t2.b</span><br><span class="line">当t2.b上没有索引时,此时需要进行全表扫描,此时扫描行数为N<span class="operator">*</span>M,不过mysql进行了优化为 Block Nested<span class="operator">-</span>Loop <span class="keyword">Join</span>(BNL)</span><br></pre></td></tr></table></figure>

<h3 id="Block-Nested-Loop-join"><a href="#Block-Nested-Loop-join" class="headerlink" title="Block Nested-Loop join"></a>Block Nested-Loop join</h3><ol>
<li>首先将t1表数据读到<strong>join buffer</strong>中</li>
<li>扫描表t2,把<strong>t2表中每一行数据和内存中t1表进行比较</strong>,将满足条件的作为结果即返回</li>
<li>扫描行数:N+M  比较次数:M*N</li>
<li>如果join buffer不够使用,t1表需要被<strong>拆分成多次放入join buffer</strong>,假设拆分为k次 ,k (0,1)</li>
<li>此时扫描行数:N+kN<em>M 比较次数:N</em>M  <strong><font color="#0000dd">当N越大的时候,被拆分的越多k则越大</font></strong></li>
<li>所以当小表为驱动表时,<strong>拆分后的k越小则扫描行数越少</strong></li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li><p>是否使用join来查询?</p>
<ul>
<li>使用,如果分开为两次查询,扫描行数一样  但是sql的执行次数不变</li>
</ul>
</li>
<li><p>选择小表作为驱动表还是大表作为驱动表?</p>
<ul>
<li><strong>当join buffer足够大时(能一次加载驱动表到内存中时),结果一样</strong></li>
<li><strong>当join buffer不够使用,需要拆分为多次加载驱动表时,选择小表为驱动表;</strong></li>
</ul>
</li>
<li><p>小表为驱动表的好出?</p>
<ul>
<li>减少表的扫描行数,降低磁盘cpu</li>
<li>当为BNL时,驱动表较大且为冷数据时,会导致<strong>LRU缓存中数据都是冷数据</strong>,因为两次查询间隔一秒后加入到LRU young区</li>
</ul>
</li>
<li><p>什么叫做小表?</p>
<ul>
<li><strong><font color="#dd0000">满足条件的行越小,相同条件满足的行放入到join buffer字段数越少越小</font></strong></li>
</ul>
</li>
</ol>
<h3 id="MMR-优化"><a href="#MMR-优化" class="headerlink" title="MMR 优化"></a>MMR 优化</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> t1.a <span class="operator">&gt;=</span><span class="number">50</span> <span class="keyword">and</span> t1.a <span class="operator">&lt;=</span><span class="number">100</span></span><br></pre></td></tr></table></figure>

<ol>
<li>MMR优化首先将a索引满足条件对的id,先加载到read_rnd_buffer表</li>
<li>read_rnd_buffer对<strong>id进行排序</strong></li>
<li><strong>读取磁盘上行数据,将随机读变为顺序读</strong></li>
<li>特点:区间查询,可以先得到满足条件的值<strong>排完顺序后</strong>回表查询</li>
</ol>
<h3 id="Batched-Key-Access"><a href="#Batched-Key-Access" class="headerlink" title="Batched Key Access"></a>Batched Key Access</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 straight_join t2 <span class="keyword">on</span> t1.a <span class="operator">=</span> t2.a</span><br></pre></td></tr></table></figure>

<ol>
<li>由于 index Nested-Loop join中每次都需要读取一行数据去t2表中查询,t2回表后返回数据,并没有使用join buffer</li>
<li><strong>BKA</strong>首先将t1表中满足条件的行数据加入到join buffer中,从join buffer中取数据查询t2表</li>
</ol>
<h3 id="BNL优化"><a href="#BNL优化" class="headerlink" title="BNL优化"></a>BNL优化</h3><ol>
<li><p>当join buffer不够使用时,<strong>可能多次扫描被驱动表,占用磁盘io</strong></p>
</li>
<li><p>判断join需要执行M<em>N比较,当*<em>数据量较大的时候,会占用非常多的cpu资源</em></em></p>
</li>
<li><p>可能会导致buffer pool的<strong>热数据失效,影响内存命中率</strong></p>
</li>
<li><p>将BNL转为BKA执行,比如**<font color="#dd0000">在连表字段上加索引,通过临时表的方式减少比较次数</font>**</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">join</span> t2 <span class="keyword">on</span> (t1.b<span class="operator">=</span>t2.b) <span class="keyword">where</span> t2.b<span class="operator">&gt;=</span><span class="number">1</span> <span class="keyword">and</span> t2.b<span class="operator">&lt;=</span><span class="number">2000</span>;</span><br><span class="line"><span class="number">1.</span>先将t2表中满足条件的数据,存储到临时表中</span><br><span class="line"><span class="number">2.</span>临时表对应的b字段加索引,t1来关联temp表</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="8、排序"><a href="#8、排序" class="headerlink" title="8、排序"></a>8、排序</h1><h3 id="全字段排序"><a href="#全字段排序" class="headerlink" title="全字段排序"></a>全字段排序</h3><ol>
<li><p>比如数据库有id,name,age….等字段,id: 主键索引 name: 普通索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name,age <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="operator">=</span> &quot;王五&quot; <span class="keyword">order</span> <span class="keyword">by</span> age limit <span class="number">10</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当查询字段较少的时候,首先innodb根据<strong>普通索引等值查询</strong>王五,直到<strong>第一个不满足等于条件</strong>或者<strong>查询到10条数据为止</strong>,执行过程</p>
<ul>
<li><strong>初始化sort buffer</strong>,存放name,age两个字段</li>
<li>根据name&#x3D;”王五”<strong>查询普通索引找到第一个满足条件的id</strong></li>
<li>根据**id到主键索引查找行记录,**取出name,age两个字段,<strong>存入到sort buffer中</strong></li>
<li>继续取下一个满足条件的元素,执行第二步和第三步;<strong>直到不相等</strong></li>
<li><strong>对sort buffer进行根据age排序</strong>,<strong>筛选出10条数据</strong>,返回结果</li>
<li>注意事项:当sort buffer空间不够时,会使用**<font color="#006600">临时文件来赋值排序,临时文件外部排序即多个文件归并排序</font>**</li>
</ul>
</li>
</ol>
<h3 id="rowid排序"><a href="#rowid排序" class="headerlink" title="rowid排序"></a>rowid排序</h3><ol>
<li><p>当数据库有id,name,age,city…等30个字段时 id:主键 name:普通索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="operator">=</span> &quot;小三&quot; <span class="keyword">order</span> <span class="keyword">by</span> age limit <span class="number">1000</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当查询字段较多时**,innodb比较后发现sort buffer放不下**,一次读取的行有限<strong>此时可能采用rowId排序</strong>,执行过程</p>
<ul>
<li>存储话sort buffer,存放id,age两个字段</li>
<li>根据name&#x3D;”王五”查询普通索引,找到第一个满足条件的id</li>
<li>根据**<font color="#dd0000">id回表查询</font><strong>,</strong><font color="#006600">取出行记录中的age,</font>**放入到sort buffer中</li>
<li>继续去下一个满足条件元素,重复执行第二步和第三步</li>
<li>对sort buffer中age排序,<strong>筛选1000条记录,获取id</strong></li>
<li>根据**<font color="#dd0000">id回表查询需要查询的所有字段,</font>**在返回给客户端</li>
<li><strong><font color="#0000dd">注意事项:两次回表查询操作,sort buffer中存储id和排序字段节约空间,但是磁盘要读取两次</font></strong></li>
</ul>
</li>
</ol>
<h3 id="联合索引排序"><a href="#联合索引排序" class="headerlink" title="联合索引排序"></a>联合索引排序</h3><ol>
<li>假设建立联合索引(name,age),在使用过程中根据name筛选时，age已经排好序,无需filter sort。此时可以在extra中看到无filter sort;最好还可以覆盖索引查询即只查询name和age字段,或者不能避免则回表查询</li>
</ol>
<p><strong><font color="#0000dd">以下内容转载自:<a target="_blank" rel="noopener" href="https://it.cha138.com/shida/show-474796.html">https://it.cha138.com/shida/show-474796.html</a></font></strong></p>
<h4 id="联合索引拓展"><a href="#联合索引拓展" class="headerlink" title="联合索引拓展"></a>联合索引拓展</h4><blockquote>
<p>联合索引（也叫组合索引、复合索引、多列索引）是指对表上的<strong>多个列进行索引</strong>。联合索引的创建方法跟单个索引的创建方法一样，不同之处仅在于有多个索引列。</p>
</blockquote>
<p>先弄一张学生表，表数据如下：</p>
<img src="/images/Snipaste_2023-02-07_22-56-14.png" alt="表1" style="zoom: 67%;" />

<p>下面我们给出一个需求：查询表中以字母”L”开头的姓名及年龄。</p>
<p><strong>1、常规的写法（回表查询）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT name,age FROM `t_user` where name like &#x27;l%&#x27; ;</span><br></pre></td></tr></table></figure>

<p>这种写法，明显效率是低下的，我们用explain 分析一下：<br><img src="/images/Snipaste_2023-02-07_23-02-37.png" alt="img"><br>由图中可以看出，在数据库中进行了全表扫描。下面我们看一下数据库中的执行过程。</p>
<ul>
<li><p>第一步：<strong>全表扫描</strong>数据，找出以“l”开头的<strong>主键id.</strong></p>
</li>
<li><p>第二步：将所有查询出来的数据<strong>每一个都回表，根据id来查询出想要的数据。</strong></p>
</li>
</ul>
<p><strong>2.优化写法（索引覆盖）</strong><br>因为我们要查询name和age。所以，我们<strong>对name和age建立了联合索引</strong>，建立后的索引图如下：<br><img src="https://image.cha138.com/20221202/59d28ba82bd64284b8015c0d21298683.jpg" alt="img"><br>从图中我们可以看出，<strong>叶子节点中的键值都是按顺序存储的并且都包含了名字和年龄，</strong>即(“Ann”,36)、(“HanMeimei”,17)、(“Kate”,17)、(“LiLei”,18)、(“Lili”,16)、(“Lisa”,19)、(“Lucy”,17)、(“WeiHua”,32)、(“ZhangWei”,18)、(“ZhangWei”,25)。</p>
<p>**<font color="#006600">索引会先根据 name 排序，如果 name 相同，再根据 age 进行排序</font>**。</p>
<p>我们对name和age建立索引后，当我们查询name和age二个字段时，直接会**<font color="#0000dd">从索引中查出来而不需要回表查询</font><strong>，这种方式就是</strong>索引覆盖**。执行步骤是这样的：</p>
<ul>
<li>第一步：使用联合索引（name，age）查询以“l”开头的数据</li>
<li>第二步：在索引中取出name和age.</li>
</ul>
<p>这种方式是不是高效多了，你要是还不信，我们用explain看一下，如下图：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT name,age FROM `t_user` where name like &#x27;l%&#x27; ;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Snipaste_2023-02-08_05-35-13.png" alt="img"><br>从图中我们看的出，<strong>使用了（name,age)索引</strong>。</p>
<h4 id="联合索引最左匹配原则"><a href="#联合索引最左匹配原则" class="headerlink" title="联合索引最左匹配原则"></a>联合索引最左匹配原则</h4><p>联合索引在使用的时候一定要注意顺序，一定要注意符合最左匹配原则。</p>
<p><strong><font color="#0000dd">最左匹配原则</font><strong>：</strong>在通过联合索引检索数据时，从索引中最左边的列开始，一直向右匹配，如果遇到范围查询(&gt;、&lt;、between、like等)，就停止后边的匹配。</strong></p>
<p>这个定义不太好理解，我解释一下：</p>
<p><strong>假如对字段 (a, b, c) 建立联合索引</strong>，现在有这样一条查询语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">where a &gt; xxx and b=yyy and c=zzz</span><br><span class="line">where a like &#x27;xxx%&#x27; and b=yyy and c=zzz</span><br></pre></td></tr></table></figure>

<p>在这两个条件语句中，**<font color="#dd0000">只有a用到了索引，后面的b,c就不会用到索引。</font>**这就是“如果遇到范围查询(&gt;、&lt;、between、like等)，就停止后边的匹配。”的意思。</p>
<p>我们还是假如对字段 (a, b, c) 建立联合索引，</p>
<p><strong>1.如下查询语句可以使用到索引：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">where</span> a <span class="operator">=</span> xxx</span><br><span class="line"><span class="keyword">where</span> a <span class="operator">=</span> xxx <span class="keyword">and</span> b <span class="operator">=</span> xxx</span><br><span class="line"><span class="keyword">where</span> a <span class="operator">=</span> xxx <span class="keyword">and</span> b <span class="operator">=</span> xxx <span class="keyword">and</span> c <span class="operator">=</span> xxx</span><br><span class="line"><span class="keyword">where</span> a <span class="keyword">like</span> <span class="string">&#x27;xxx%&#x27;</span></span><br><span class="line"><span class="keyword">where</span> a <span class="operator">&gt;</span> xxx</span><br><span class="line"><span class="keyword">where</span> a <span class="operator">=</span> xxx <span class="keyword">order</span> <span class="keyword">by</span> b</span><br><span class="line"><span class="keyword">where</span> a <span class="operator">=</span> xxx <span class="keyword">and</span> b <span class="operator">=</span> xxx <span class="keyword">order</span> <span class="keyword">by</span> c <span class="keyword">group</span> <span class="keyword">by</span> a</span><br></pre></td></tr></table></figure>

<p><strong>2.如下查询条件也会使用索引：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">where</span> b <span class="operator">=</span> xxx <span class="keyword">and</span> a <span class="operator">=</span> xxx   <span class="operator">!</span><span class="operator">!</span><span class="operator">!</span><span class="operator">!</span></span><br><span class="line"><span class="keyword">where</span> a <span class="operator">=</span> xxx <span class="keyword">and</span> c <span class="operator">=</span> xxx <span class="keyword">and</span> b <span class="operator">=</span> xxx   <span class="operator">!</span><span class="operator">!</span><span class="operator">!</span><span class="operator">!</span></span><br></pre></td></tr></table></figure>

<p>虽然b和a的顺序换了，但是<strong>mysql中的优化器</strong>会帮助我们调整顺序。</p>
<p><strong>3.如下查询条件只用到联合索引的一部分：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">where a = xxx and c = xxx   可以用到 a 列的索引，用不到 c 列索引。!!</span><br><span class="line">where a like &#x27;xxx%&#x27; and b = xxx 可以用到 a 列的索引，用不到 b 列的索引。</span><br><span class="line">where a &gt; xxx and b = xxx 可以用到 a 列的索引，用不到 b 列的索引。</span><br></pre></td></tr></table></figure>

<p><strong>4.如下查询条件完全用不到索引</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">where b = xxx   !!!</span><br><span class="line">where c = xxx</span><br><span class="line">where a like &#x27;%xxx&#x27;			-- 不满足最左前缀</span><br><span class="line">where d = xxx order by a	-- 出现非排序使用到的索引列 d </span><br><span class="line">where a + 1 = xxx	-- 使用函数、运算表达式及类型隐式转换等</span><br></pre></td></tr></table></figure>

<p><strong>如何选择合适的联合索引</strong></p>
<p>1.<code>where a = xxx and b = xxx and c = xxx</code> 如果我们的查询是这样的，建索引时，就可以考虑**<font color="#0000dd">将选择性高的列放在索引的最前列，选择性低的放后边。</font>**</p>
<p>2.如果是<code>where a &gt; xxx and b = xxx 或 where a like ‘xxx%’ and b = xxx</code>这样的语句，**<font color="#0000dd">可以对 (b, a) 建立索引。</font>**</p>
<p>3.如果是<code>where a = xxx order by b</code>这样的语句，**<font color="#0000dd">可以对 (a, b) 建立索引</font>**。</p>
<h4 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h4><p>索引覆盖在上面我们已经介绍了。由上面的介绍我们知道，**<font color="#dd0000">建立了联合索引后，直接在索引中就可以得到查询结果，从而不需要回表查询聚簇索引中的行数据信息。</font>**</p>
<p>索引覆盖可以带来很多的<strong>好处</strong>：</p>
<ul>
<li><strong>辅助索引不包含行数据的所有信息</strong>，故其<strong>大小远小于聚簇索引</strong>，因此可以<strong>减少大量的IO操作</strong>。</li>
<li>索引覆盖只需要扫描一次索引树，不需要回表扫描聚簇索引树，所以<strong>性能比回表查询要高。</strong></li>
<li>索引中列值是<strong>按顺序存储的</strong>，索引覆盖能避免<strong>范围查询回表带来的大量随机IO操作。</strong> 判断一条语句是否用到索引覆盖：</li>
</ul>
<p>这个我们需要用explain查看一下。<br><img src="/images/Snipaste_2023-02-08_05-37-17.png" alt="img"><br>Using index 就表示使用到了索引 , 并且所取的数据完全在索引中就能拿到，也就是用到了索引覆盖。</p>
<h4 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h4><p>索引下推是索引下推是 <strong>MySQL 5.6</strong> 及以上版本上推出的，用于<strong>对查询进行优化</strong>。</p>
<p><strong><font color="#dd0000">索引下推</font><strong>是把</strong><font color="#006600">本应该在 server 层进行筛选的条件，下推到存储引擎层来进行筛选判断，这样能有效减少回表。</font></strong></p>
<p>举例说明：</p>
<p>首先使用联合索引（name，age），现在有这样一个查询语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select *  from t_user where name like &#x27;L%&#x27; and age = 17;</span><br></pre></td></tr></table></figure>

<p>这条语句从<strong>最左匹配原则上来说是不符合</strong>的，原因在于只有name用的索引，但是age并没有用到。</p>
<p><strong>不用索引下推的执行过程：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一步：利用索引找出name带&#x27;L&#x27;的数据行：LiLei、Lili、Lisa、Lucy 这四条索引数据</span><br><span class="line">第二步：再根据这四条索引数据中的 id 值，逐一进行回表扫描，从聚簇索引中找到相应的行数据，将找到的行数据返回给 server 层。</span><br><span class="line">第三步：在server层判断age = 17,进行筛选，最终只留下 Lucy 用户的数据信息。</span><br></pre></td></tr></table></figure>

<p><strong>使用索引下推的执行过程：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第一步：利用索引找出name带&#x27;L&#x27;的数据行：LiLei、Lili、Lisa、Lucy 这四条索引数据</span><br><span class="line">第二步：根据 age = 17 这个条件，对四条索引数据进行判断筛选，最终只留下 Lucy 用户的数据信息。</span><br><span class="line">（注意：这一步不是直接进行回表操作，而是根据 age = 17 这个条件，对四条索引数据进行判断筛选）</span><br><span class="line">第三步：将符合条件的索引对应的 id 进行回表扫描，最终将找到的行数据返回给 server 层。</span><br></pre></td></tr></table></figure>

<p>比较二者的第二步我们发现，索引下推的方式极大的**<font color="#dd0000">减少了回表次数</font>**。</p>
<p><strong>索引下推需要注意的情况：</strong></p>
<p>下推的**<font color="#0000dd">前提</font>**是索引中有 age 列信息，如果是其它条件，如 gender &#x3D; 0，这个即使下推下来也没用</p>
<p><strong>开启索引下推：</strong></p>
<p>索引下推是 MySQL 5.6 及以上版本上推出的，用于对查询进行优化。默认情况下，索引下推处于启用状态。我们可以使用如下命令来开启或关闭。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set optimizer_switch=&#x27;index_condition_pushdown=off&#x27;; 	-- 关闭索引下推</span><br><span class="line">set optimizer_switch=&#x27;index_condition_pushdown=on&#x27;;		-- 开启索引下</span><br></pre></td></tr></table></figure>



<h3 id="order-by或group-by临时表"><a href="#order-by或group-by临时表" class="headerlink" title="order by或group by临时表"></a>order by或group by临时表</h3><ol>
<li>比如随机筛选表中三个单词,words表中有 word字段,比如10000行数据<ul>
<li><code>select word from words order by rand() limit 3</code></li>
</ul>
</li>
<li>执行流程<ul>
<li>构建临时表字段W和R</li>
<li>全表扫描根据主键筛选出表words中的word字段,同时调用随机函数rand()生成R,**将数据放入到临时表中,**此时无序存储;此时扫描10000行</li>
<li>构建sort buffer,包括R和POS(rowid:主键索引–&gt;唯一索引非空–&gt;自动分配6字节rowId);扫描临时表将临时表中R和POS架子啊到sort buffer中此时扫描10000行</li>
<li>sort buffer排序(此处排序不一定是快速排序,因为只需要3条数据),排序完筛选前三条数据</li>
<li>根据前三条数据的POS到临时表中找到对应的W字段即word返回结果,此处需要根据pos到临时表扫描3行</li>
<li>排序:此处使用堆排序构建<strong>大顶堆</strong>(优先队列排序算法,未使用临时文件进行归并排序)</li>
</ul>
</li>
</ol>
<h1 id="9、sql优化"><a href="#9、sql优化" class="headerlink" title="9、sql优化"></a>9、sql优化</h1><h3 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h3><ol>
<li><code>show index from 表;</code><br><img src="/images/8705.octet-stream" alt="image-20191119164200193"></li>
<li><code>table</code>:表名</li>
<li><code>non_unique</code>: 0:代表唯一索引 1:非唯一索引</li>
<li><code>Key_name</code>:索引名称</li>
<li><code>seq_in_index</code>:索引在下标比如联合索引ca,c:1 a:2</li>
<li><code>column_name</code>:字段的名称</li>
<li><code>collation</code>:A:btree</li>
<li><code>Cardinality</code>:随机从数据库中选择8条数据,不同的数据有几条  当为1时不适合建立索引</li>
<li>注意事项:在mysql执行的过程中优化器可能选择不是自己想要的索引,可以在查询表后面指定索引<code>force index</code>(索引名称)</li>
</ol>
<h3 id="explain"><a href="#explain" class="headerlink" title="explain"></a>explain</h3><ol>
<li><p><strong><font color="#0000dd"><code>select_type</code>:  查询类型</font></strong></p>
<ul>
<li><code>simple</code>:简单的select查询,查询不包含子查询或者union</li>
<li><code>primary</code>:查询中包含任何复杂的子查询,最外层查询则被标记为primary</li>
<li><code>subquery</code>:在select或where列表中包含了子查询</li>
<li><code>derived</code>:在from列表中包含的子查询被标记为derived(衍生)Mysql会递归执行这些子查询,把结果放在临时表里</li>
<li><code>union</code>:若<strong>第二个select出现在union之后,<strong>则被标记为<code>union</code>;若</strong>union包含在from子句的子查询</strong>中,<strong>外层select</strong>将被标记为:<code>derived</code></li>
<li><code>union result</code>:从union表获取结果的select</li>
</ul>
</li>
<li><p><strong><font color="#0000dd"><code>type</code>: 连接类型</font></strong></p>
<ul>
<li><code>all</code>:全表扫面</li>
<li><code>index</code>:<strong><font color="#dd0000">全索引文件扫描</font></strong>,直接遍历二级索引<strong>不用回表查询聚簇索引</strong>(<strong><font color="#006600">比如联合索引name,age 按age范围查询</font></strong>)</li>
<li><code>range</code>:<strong>只检索给定范围的行</strong>,使用索引来匹配行.sql中一般会有between in &gt; &lt;等查询</li>
<li><code>ref</code>:<strong>非唯一索引</strong>或<strong>主键索引唯一索引使用is null或is not null</strong>(ref_or_null)</li>
<li><code>eq_ref</code>:唯一性索引扫描,**对于每个索引键,**表中有一条记录与之匹配.</li>
<li><code>const</code>:表示通过<strong>索引一次可以找到</strong> 用于primary key或者unique索引(主键和唯一索引)</li>
<li><code>system</code>:表<strong>只有一条记录</strong>(等于系统表),这是<strong>const类型的特列</strong></li>
<li>性能:system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;all</li>
</ul>
</li>
<li><p><strong><font color="#0000dd">possible_keys</font></strong>:显示查询语句**可能用到的索引(一个或多个或为null),**不一定被查询实际使用</p>
</li>
<li><p><strong><font color="#0000dd">key</font></strong>:显示查询语句实际使用的索引.<strong>若为null,则表示没有使用索引</strong></p>
</li>
<li><p><strong><font color="#0000dd">key_len</font></strong>:显示<strong>索引中使用的字节数</strong>,长度越短越好</p>
</li>
<li><p><strong><font color="#0000dd">ref</font></strong>:显示索引的哪一列或常量被用于查找索引列上的值</p>
</li>
<li><p><strong><font color="#0000dd">rows</font></strong>:根据表统计信息及索引选用情况,大致估算出找到<strong>所需要读取的行数</strong>,值越小越好</p>
</li>
<li><p><strong><font color="#0000dd">extra</font></strong>:扩展内容</p>
<ul>
<li><code>Using filesort</code>:<strong>排序时通过sort buffer排序</strong></li>
<li><code>Using temporary</code>:使用<strong>临时表来存储数据比如group by</strong></li>
<li><code>using index</code>:<strong>覆盖索引查询</strong></li>
<li><code>using index condition</code>:<strong>索引下推,减少回表查询无效数据</strong></li>
<li><code>using where</code>:<strong>不走索引查询</strong></li>
<li><code>using where;using index</code>:走索引查询,<strong>查询的字段不需要回表查询</strong> 对比覆盖索引查询多了过滤</li>
<li><code>block nested loop join</code>:加载驱动表到<strong>join buffer被驱动逐行判断</strong></li>
<li><code>Index nested loop join</code>:驱动表<strong>扫描一行数据后去被驱动表普通索引查询</strong></li>
</ul>
</li>
</ol>
<h3 id="成本分析-说得什么玩意。TODO"><a href="#成本分析-说得什么玩意。TODO" class="headerlink" title="成本分析 ????说得什么玩意。TODO"></a>成本分析 ????说得什么玩意。TODO</h3><ol>
<li>读一页成本1.0</li>
<li>条件筛选排序分组一条符合数据的成本为0.2</li>
<li>表对应的数据页:<ul>
<li><code>show table status like &#39;notice_info_0&#39;;</code></li>
<li>数据页:<code>Data_length/16KB=32047104/1000/16=2002数据页</code></li>
<li>行数:<code>Rows 111971行</code></li>
</ul>
</li>
<li>分析成本按name字段查询100行数据:<ul>
<li>全表查询读取所有的数据页:<code>2000  筛选出来100行  2000 * 1.0+100 * 0.2=2020</code></li>
<li>name字段有普通索引: 普通索引假设区间查找一个数据页 普通索引:1+100*0.2&#x3D;21  回表查询:假设100行每一行都读取一个数据页 100 * 1.0 + 100 * 0.2&#x3D;120 成本:120+21&#x3D;141</li>
</ul>
</li>
</ol>
<h3 id="回表查询"><a href="#回表查询" class="headerlink" title="回表查询"></a>回表查询</h3><ol>
<li>概念:<strong><font color="#dd0000">先查询普通索引页获取到主键id,在根据主键id查询主键索引页</font></strong></li>
<li>示例:<ul>
<li>比如数据库中有a,b,c,d字段  此时(a,b)字段建立联合索引</li>
<li><code>select d from t where a = 1 and b &gt; 1 and d = 2</code>  todo分析</li>
</ul>
</li>
</ol>
<h3 id="覆盖索引查询"><a href="#覆盖索引查询" class="headerlink" title="覆盖索引查询"></a>覆盖索引查询</h3><ol>
<li>概念:<strong><font color="#0000dd">当查询数据的时候,如果数据在普通索引中已经存在,则不需要根据主键去主键索引上定位行数据获取</font></strong></li>
<li>示例:<ul>
<li>比如数据库有联合索引(name,age) </li>
<li>查询<code> select name,age from user where name=&quot;张三&quot;</code>,<strong>此时不需要回表查询</strong></li>
</ul>
</li>
</ol>
<h3 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h3><ol>
<li><p>查询条件对<strong>所有进行函数类型转换</strong>导致全索引文件扫描比如<code>month(字段)=7</code></p>
</li>
<li><p>索引字段类型<strong>转换导致索引失效</strong>,数据库中数据转型为string转integer,比如查询sql name(varchar) </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="number">123423</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>字符编码类型转换</strong>导致索引失效</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t2.<span class="operator">*</span> <span class="keyword">from</span> t1,t2 <span class="keyword">where</span> t1.rowId <span class="operator">=</span> t2.rowId <span class="keyword">and</span> t1.id<span class="operator">=</span><span class="number">1</span></span><br><span class="line">t1:utf8m64 t2:utf8</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t2.<span class="operator">*</span> <span class="keyword">from</span> t2 <span class="keyword">where</span> t2.rowId <span class="operator">=</span> $t1.rowId</span><br><span class="line">此时t2.rowId为utf8  t1根据id拿到rowId为utf8m64</span><br><span class="line">utf8 <span class="number">3</span>字节 utf8m64 <span class="number">4</span>字节:此时t2表rowId索引要全索引文件扫描</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>优化器选错索引</strong></p>
<ul>
<li>由于优化器中表数据问题,可以通过<code>alter table engine = innodb</code>,在查询sql</li>
<li>通过<code>force index</code><strong>指定索引名称</strong></li>
</ul>
</li>
</ol>
<h3 id="案例一-子查询被优化为join"><a href="#案例一-子查询被优化为join" class="headerlink" title="案例一:子查询被优化为join"></a>案例一:子查询被优化为join</h3><ol>
<li><p>&#96;&#96;&#96;sql<br>select id,name from users<br>where id in (select user_id from users_extent_info<br>                 where latest_login_time &lt; xxx)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. sql执行计划:</span><br><span class="line">   ![image-20200921103512827](/images/WEB16b7eb5df1a8507eb11b744b6d15dbda.octet-stream)</span><br><span class="line"></span><br><span class="line">3. **&lt;font color=&quot;#dd0000&quot;&gt;分析sql执行计划:&lt;/font&gt;**</span><br><span class="line"></span><br><span class="line">   - 第三条执行计划,子查询`users_extent_info`表,使用索引`idx_login_time`,进行`range范围查询`,`筛选出4561行数据filtered=100`**不需要进行过滤**,**临时表将4561行数据存储到磁盘临时表中**</span><br><span class="line">   - 第二条执行计划,查询`users表`通过extra知道使用的是`join buffer(nested loop)`,**&lt;font color=&quot;#0000dd&quot;&gt;说明users表为被驱动表,临时表为驱动表&lt;/font&gt;**,**&lt;font color=&quot;#006600&quot;&gt;先将驱动表放入到join buffer中;然后users表进行全表扫描出来49651行数据遍历每一行去join buffer中跟物化表进行比较&lt;/font&gt;**</span><br><span class="line">   - 第一条执行计划**全表查询两个表管理后的结果**</span><br><span class="line"></span><br><span class="line">4. **&lt;font color=&quot;#dd0000&quot;&gt;解决方案&lt;/font&gt;**</span><br><span class="line"></span><br><span class="line">   - 问题: mysql 将子查询优化为了join操作还是nested Loop Join</span><br><span class="line"></span><br><span class="line">   - 解决方案:</span><br><span class="line"></span><br><span class="line">     ```sql</span><br><span class="line">     select id,name from users </span><br><span class="line">     		where id in (select user_id from users_extent_info </span><br><span class="line">                          where latest_login_time &lt; xxx </span><br><span class="line">                          union </span><br><span class="line">                          select user_id from users_extent_info </span><br><span class="line">                          where latest_login_time is null )</span><br></pre></td></tr></table></figure>

<p>  让优化器走查查询的操作</p>
<ul>
<li>最后的执行计划:先查询<code>users_extent_info range</code>范围查询获取到userid,然后<strong>根据userId来查询聚簇索引页</strong></li>
</ul>
</li>
</ol>
<h3 id="案例二-优化器未选择索引走全表扫描"><a href="#案例二-优化器未选择索引走全表扫描" class="headerlink" title="案例二:优化器未选择索引走全表扫描"></a>案例二:优化器未选择索引走全表扫描</h3><ol>
<li><pre><code class="sql">explain select * from products 
where category = &#39;xxx&#39; and sub_category=&#39;xxx&#39; 
order by id desc 
limit xx,x
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 商品表的数据大概是**1亿左右**,优化器未选择索引,因为优化器认为选择了索引之后筛选完之后需要根据**&lt;font color=&quot;#dd0000&quot;&gt;id进行内存临时表倒序排序&lt;/font&gt;**然后进行limit操作后再进行回表查询,优化器选择了**聚簇索引查询**</span><br><span class="line"></span><br><span class="line">3. 此时存在问题是聚簇索引查询的时候由于**设置了不存在的条件导致全表扫描**</span><br><span class="line"></span><br><span class="line">4. 优化方案:**force index**强制优化器来使用**二级索引查询**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 案例三:分库分表的商品查询选择索引后效率低</span><br><span class="line"></span><br><span class="line">1. ```sql</span><br><span class="line">   select * from comments </span><br><span class="line">   where product_id = &#x27;xx&#x27; and is_good_comment=&#x27;1&#x27; </span><br><span class="line">   order by id desc </span><br><span class="line">   limit 100000,20,</span><br><span class="line">   </span><br><span class="line">   索引字段:product_id</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>优化器选择了<strong>product_id的索引</strong>,此时的执行顺序是先根据**<font color="#0000dd">product_id查询二级索引获取所有的id</font><strong>,然后</strong><font color="#0000dd">id进行内存临时表进行倒序排序之后在进行回表查询所有id</font><strong>，然后</strong><font color="#0000dd">内存筛选 is_good_comment&#x3D;1  的行数据深度分页查询到第100000页数据后筛选20条数据</font>**结果返回</p>
</li>
<li><p>&#96;&#96;&#96;sql<br>优化sql为<br>select * from comments a<br>inner join (select id from comments<br>            where product_id &#x3D; ‘xx’ and is_good_comment&#x3D;’1’<br>            order by id desc<br>            limit 100000,20) b where a.id &#x3D; b.id</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 10、count 和 delete </span><br><span class="line"></span><br><span class="line">### delete （TODO 又不说人话。。）</span><br><span class="line"></span><br><span class="line">1. 数据空间复用: 比如当前页中存在数据 100 200 300,如果删除该页200的数据,200的位置标记位可复用之后插入100到300之间的数据可以复用当前位置</span><br><span class="line">2. 页复用:当该页上的所有数据都可以被复用的时候,当前页被标记位可复用;当新插入的数据需要新的页时可以复用该页</span><br><span class="line">3. 数据存储格式:页(地址值)  页上数据(数组顺序存储)  父节点页(地址值) 父节点数据(left + right + 数组下标)</span><br><span class="line">4. 空间复用只是标记了可复用,但磁盘的文件大小是没变的,会生成很多的位置空洞情况</span><br><span class="line">5. alter table engine = Innodb 来清除;原理在Innodb存储引擎中生成一份临时文件,数据从当前页拷贝;在整理临时文件将页数据重新紧凑排版;如果这个过程中新的数据插入则保存到row log中,之后再恢复到拷贝的新文件中</span><br><span class="line">   对server层来说是原地拷贝(inplace);Innodb即online(1.MDL写锁 MDL读锁 DDL MDL写锁 MDL读锁)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### count()</span><br><span class="line"></span><br><span class="line">1. count(*):遍历所有数据,**&lt;font color=&quot;#0000dd&quot;&gt;不返回行数据,执行器+1&lt;/font&gt;,&lt;font color=&quot;#dd0000&quot;&gt;所以这个最优！&lt;/font&gt;**   </span><br><span class="line">2. count(1):遍历所有数据,**&lt;font color=&quot;#0000dd&quot;&gt;返回行数据+1,&lt;/font&gt;&lt;font color=&quot;#dd0000&quot;&gt;(不判断为空)&lt;/font&gt;**</span><br><span class="line">3. count(id):走**&lt;font color=&quot;#0000dd&quot;&gt;最小索引树,&lt;/font&gt;**如果没有则走id,返回给执行器id,**&lt;font color=&quot;#dd0000&quot;&gt;执行器判断是否为空 不为空则+1&lt;/font&gt;**</span><br><span class="line">4. count(字段):**&lt;font color=&quot;#0000dd&quot;&gt;判断改字段是否是索引,是则走当前字段的索引树,不是则走id&lt;/font&gt;**</span><br><span class="line">5. 效率: count(*)=count(1) &gt; count(id) &gt; count(字段)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 11、锁分析  TODO</span><br><span class="line"></span><br><span class="line">#### 1、等值查询间隙锁</span><br><span class="line"></span><br><span class="line">```sql</span><br><span class="line">begin;</span><br><span class="line">update t set d= d+1 where id=7;</span><br><span class="line"></span><br><span class="line">- 根据原则1,id=7在 (5,10]上next-key lock</span><br><span class="line">- id=7在数据库中不存在</span><br><span class="line">- 优化1不满足,</span><br><span class="line">- 优化2:等值查询,向右找到最后一个不满足的值为10,此时降级为间隙锁(5,10)</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="2、非唯一锁等值锁"><a href="#2、非唯一锁等值锁" class="headerlink" title="2、非唯一锁等值锁"></a>2、非唯一锁等值锁</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> c <span class="operator">=</span> <span class="number">5</span> lock <span class="keyword">in</span> share mode;</span><br></pre></td></tr></table></figure>

<ul>
<li>根据原则1:<strong>普通索引c区间 (0,5]</strong></li>
<li>:由于c&#x3D;5是普通索引,需要向右遍历找到不相等为止,根据原则2访问的对象加锁此时 (5,10]</li>
<li>优化1:等值查询(5,10]降级为(5,10)</li>
<li>优化2:此时查询字段为id,不需要回表查询即不会在id&#x3D;5上加行锁,此时可以更新id&#x3D;5</li>
<li>lock in share mode:只会锁覆盖索引,不会锁主键;当for update时,innodb认为你查询后会根据id更新此时会获取id&#x3D;5的行锁</li>
</ul>
<h4 id="3、主键索引范围锁"><a href="#3、主键索引范围锁" class="headerlink" title="3、主键索引范围锁"></a>3、主键索引范围锁</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">10</span>  <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id <span class="operator">&gt;=</span> <span class="number">10</span> <span class="keyword">and</span> id <span class="operator">&lt;</span> <span class="number">11</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>两者查询结果相同加锁不同,方式1:10在 (5,10]区间,满足优化1:等值,唯一索引 降级为行锁 id&#x3D;5</li>
<li>找到第一行id&#x3D;10的,即(5,10] 满足优化1:退化为行锁 id&#x3D;10</li>
<li>向右遍历找到第一个不满足条件数15,此时原则2访问数据(10,15] 此时id&#x3D;15是范围查找到的不能通过等值来降级</li>
</ul>
<h4 id="4、非唯一索引范围锁"><a href="#4、非唯一索引范围锁" class="headerlink" title="4、非唯一索引范围锁"></a>4、非唯一索引范围锁</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> c<span class="operator">&gt;=</span><span class="number">10</span> <span class="keyword">and</span> c<span class="operator">&lt;</span><span class="number">10</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过c&#x3D;10去查找,区间:(5,10]</li>
<li>由于是普通索引需要向右遍历找到第一个不相等值,15 即(10,15],向右遍历过程是范围查询无法优化</li>
<li>c next-key lock:(5,15]  id:10 record-lock</li>
</ul>
<h4 id="5、唯一索引范围锁bug"><a href="#5、唯一索引范围锁bug" class="headerlink" title="5、唯一索引范围锁bug"></a>5、唯一索引范围锁bug</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id <span class="operator">&gt;</span> <span class="number">10</span> <span class="keyword">and</span> id <span class="operator">&lt;=</span> <span class="number">15</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>根据原则1:通过id&#x3D;15去主键索引查询,区间 (10,15] next-key</li>
<li>本质上根据主键查询到id&#x3D;15后不会像右继续查找,存在bug 如果主键索引上范围查询,会找到下一个不满足条件的索引,即id&#x3D;20  (15,20] next-key</li>
<li>(10,20] next-key</li>
</ul>
<h4 id="6、非唯一索引上存在的等值"><a href="#6、非唯一索引上存在的等值" class="headerlink" title="6、非唯一索引上存在的等值"></a>6、非唯一索引上存在的等值</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">30</span>,<span class="number">10</span>,<span class="number">30</span>);</span><br><span class="line">此时普通索引:<span class="number">10</span>  对应两条数据 id:<span class="number">10</span>  id:<span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> t <span class="keyword">where</span> c<span class="operator">=</span><span class="number">10</span></span><br></pre></td></tr></table></figure>

<ul>
<li>根据c&#x3D;10条件查询c索引 c&#x3D;10  此时区间 (5,10]    对应的(c,id)是(5,5)和(10,10) next-key lock</li>
<li>普通索引向右遍历,原则2:访问到的元素,区间(10,15]  对应的(c,id)是 (10,30)和(15,15) next-key lock</li>
<li>根据优化2:等值查询,15条件不满足退化为gap-lock</li>
<li>此时加锁区间为(c,id)   (5,5)-(10,10)-(10,30)-(15,15)     c:(5,15)   id:行锁 10,30</li>
</ul>
<h4 id="7、limit语句加锁"><a href="#7、limit语句加锁" class="headerlink" title="7、limit语句加锁"></a>7、limit语句加锁</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> t <span class="keyword">where</span> c<span class="operator">=</span><span class="number">10</span> limit <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过c&#x3D;10从普通索引上查找,区间(5,10]</li>
<li>开始向右遍历找到满足条件元素 (c,id)   (10,10)  (10,30)  由于找到两条数据从c索引上的查找满足limit 2结束,此时不需要继续向右找到c&#x3D;15的元素</li>
<li>此时区间为(c,id)   (5,5)-(10,10)-(10,30)  普通索引c:(5,10] id: 10和30 record lock</li>
</ul>
<h4 id="8、死锁的案例"><a href="#8、死锁的案例" class="headerlink" title="8、死锁的案例"></a>8、死锁的案例</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">session A:</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> c<span class="operator">=</span><span class="number">10</span> lock <span class="keyword">in</span> share mode;</span><br><span class="line">session B:</span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> d<span class="operator">=</span>d<span class="operator">+</span><span class="number">1</span> <span class="keyword">where</span> c<span class="operator">=</span><span class="number">10</span></span><br><span class="line">session A:</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>);</span><br><span class="line">session B:</span><br><span class="line">dead lock</span><br></pre></td></tr></table></figure>

<ul>
<li>session A 第一步:获取到 (5,10] next-key  (10,15) gap</li>
<li>session B 第一步获取到:(5,10) (10,15) gap  获取 10:record lock 阻塞,因为session A获取了行锁,间隙锁和间隙锁之间不阻塞</li>
<li>session A 第二步:插入(8,8,8)被间隙锁区间(5,10)锁住,此时session A等待session b释放间隙锁(5,10),session B等待session A释放行锁,出现死锁</li>
</ul>
<h3 id="RC下update-semi-consistent-read优化"><a href="#RC下update-semi-consistent-read优化" class="headerlink" title="RC下update-semi-consistent read优化"></a>RC下update-semi-consistent read优化</h3><p><strong>在rc隔离级别下如果进行update语句,碰到一个已经被锁住的行,首先会读取最新版本行的记录,然后判断是否满足条件,不满足则直接跳过,满足则等待</strong></p>
<h1 id="12、死锁"><a href="#12、死锁" class="headerlink" title="12、死锁"></a>12、死锁</h1><h3 id="行级锁-for-update"><a href="#行级锁-for-update" class="headerlink" title="行级锁 for update"></a>行级锁 for update</h3><p>for update是一种行级锁，又叫排它锁，一旦用户对<strong>某个行施加了行级加锁</strong>，则该用户<strong>可以查询也可以更新被加锁的数据行</strong>，**<font color="#0000dd">其它用户只能查询但不能更新被加锁的数据行</font><strong>．如果其它用户想更新该表中的数据行，则也必须对该表施加行级锁．</strong><font color="#0000dd">即使多个用户对一个表均使用了共享更新，但也不允许两个事务同时对一个表进行更新，</font><strong>真正对表进行更新时，</strong><font color="#0000dd">是以独占方式锁表</font><strong>，一直到提交或复原该事务为止。</strong>行锁永远是独占方式锁。**<br>只有当出现如下之一的条件，才会释放共享更新锁：<br>1.执行提交（COMMIT）语句<br>2.退出数据库（LOG　OFF）<br>3.程序停止运行</p>
<h3 id="间隙锁扩张"><a href="#间隙锁扩张" class="headerlink" title="间隙锁扩张"></a>间隙锁扩张</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `c` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `d` <span class="type">int</span>(<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `c` (`c`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">4294967295</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>),(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>),(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th>session A</th>
<th>session B</th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td>begin;<br />select * from t where id &gt; 10 and id&lt;&#x3D;15 for update;</td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td></td>
<td>delete from t where id&#x3D;10;</td>
</tr>
<tr>
<td>T3</td>
<td></td>
<td>insert into t values(10,10,10) blocking</td>
</tr>
</tbody></table>
<ol>
<li><p>session A T1时候获取锁,(10,15] (15,20],找到第一个满足条件的值id&#x3D;15,由于存在bug,<strong>主键范围查询需要向右继续扫描到下一个不相等的即id&#x3D;20</strong></p>
</li>
<li><p>当session B T2时候删除id&#x3D;10行记录时,扫描到id&#x3D;10,获取(5,10]next-key,由于主键等值查询,**获取id&#x3D;10行锁,**删除数据,此时数据库间隙变为 (-无穷,1) (1,5) (5,15) (15,20)……</p>
</li>
<li><p>由于session A T1时候获取的间隙锁(10,15)右节点为15,10被删除后区间变为(5,15)间隙锁</p>
</li>
<li><p>session B T3时候插入数据阻塞</p>
</li>
<li><p>show engine innodb status</p>
</li>
</ol>
<ul>
<li>index primary:主键id  表:test.t</li>
<li>lock mode x locks gap before rec insert intention wating</li>
<li>gap before rec:表示这是一个间隙锁 insert intention:表示当前线程在准备一个插入操作,使用的是插入意向锁</li>
<li>n_fields 5:代表记录了5列<ol>
<li>第一列:id  0f:15 因为id&#x3D;10不存在,则间隙为(5,15)</li>
<li>第二列:长度为6的事物id   trx_id:607779</li>
<li>第三列:长度为7的回滚段</li>
<li>第四列和第五列即字段c,d (15,15)</li>
</ol>
</li>
<li>结论:所谓的间隙,间隙是由右边的值确定的</li>
</ul>
<h3 id="行锁和间隙锁"><a href="#行锁和间隙锁" class="headerlink" title="行锁和间隙锁"></a>行锁和间隙锁</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `c` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `d` <span class="type">int</span>(<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `c` (`c`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">4294967295</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>),(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>),(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th>session A</th>
<th>session B</th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td>begin;</td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td></td>
<td>begin;</td>
</tr>
<tr>
<td>T3</td>
<td>select * from t where c&#x3D;5 lock in share model;</td>
<td></td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td>Update t set d&#x3D;d+1 where c &#x3D; 5</td>
</tr>
<tr>
<td>T5</td>
<td>inser into t values(2,2,2)</td>
<td></td>
</tr>
<tr>
<td>T6</td>
<td></td>
<td>ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ol>
<li>事物A在执行T3操作时,由于字段c是普通索引,找到c普通索引c&#x3D;5的行数据加(1,5] next-key,普通索引需要遍历到下一个不相等的位置10给(5,10]加next-key,由于等值查询进行索引优化(5,10]变为(5,10)的间隙锁;同时c&#x3D;5会回表查询id给id&#x3D;5加行锁,(1,10)next-key id&#x3D;5 record key</li>
<li>事物B在执行T4操作时,首先是查找c&#x3D;5的行即执行select * from t where c&#x3D;5 for update;此时获取(1,5] next-key时获取不到c&#x3D;5的行锁因为被事物A占用了,只能获取到(1,5)的共享间隙锁;事物B等待A</li>
<li>事物A在执行T5操作时,插入c&#x3D;2的数据时,需要获取(1,5)的排他间隙锁;这样事物A等待事物B释放共享间隙锁,事物B等待事物A释放c&#x3D;5的行锁则死锁</li>
</ol>
<h3 id="show-engine-innodb-status"><a href="#show-engine-innodb-status" class="headerlink" title="show engine innodb status"></a>show engine innodb status</h3><ol>
<li>lock_mode x waiting:next-key(gap+record lock) 行锁+间隙锁</li>
<li>lock_mode x locks rec but no gap:record lock 行锁</li>
<li>lock_mode x locks gap before rec  insert intention:gap 间隙锁</li>
</ol>
<h3 id="死锁解决方案"><a href="#死锁解决方案" class="headerlink" title="死锁解决方案"></a>死锁解决方案</h3><ol>
<li>等待超时,通过show variables like “%Innodb_lock_wait_timeout%”来设置</li>
<li>死锁检测,发现死锁当前事物放弃执行.show variables like “%Innodb_deadlock_detect%”</li>
</ol>
<h1 id="13、主备"><a href="#13、主备" class="headerlink" title="13、主备"></a>13、主备</h1><h3 id="主备"><a href="#主备" class="headerlink" title="主备"></a>主备</h3><h4 id="主备原理"><a href="#主备原理" class="headerlink" title="主备原理"></a>主备原理</h4><ul>
<li>比如节点 <code>A:master B:slaver(readonly)</code> 配置<strong>从节点只读,主节点读写</strong></li>
<li>主从同步流程:<ol>
<li>主库 <code>start-&gt;undo log(mem)-&gt;data(mem)-&gt;redo log prepare-&gt;binlog-&gt;redo log commit-&gt;ack</code></li>
<li>在binlog写入后,dump thread(跟备库建立连接的线程)</li>
<li>备库上io thread和主库建立连接,备库通过change master命令告诉主库需要从binlog哪个position开始拉去数据</li>
<li>备库拿到binlog日志后写入到本地文件,relay log(中转日志)</li>
<li>备库sql thread 读取中转日志解析日志中的命令并执行</li>
</ol>
</li>
</ul>
<h4 id="binlog三种方式"><a href="#binlog三种方式" class="headerlink" title="binlog三种方式"></a>binlog三种方式</h4><ul>
<li>row:存储事物操作前后的数据结果集即物理日志</li>
<li>statement:存储事物操作前后的DML语句,逻辑日志(可能出现主从同步不一致性问题)</li>
<li>mixed:在存储binlog时会预先考虑到DML语句是否会影响结果不一致,会则row不会则statement</li>
</ul>
<h4 id="双master"><a href="#双master" class="headerlink" title="双master"></a>双master</h4><ul>
<li>两个节点都为master节点,其中一个只读,两个master之间数据双向同步</li>
<li>由于binlog中保存当了binlog产生的server id用来标识是那一个master节点的binlog,如果和自己的master节点server id相同则不同步;比如ABmaster,B(readonly),当往A库中写入数据是此时B获取到binlog日志和自己server_id不等则写入binlog数据到B库,B库写完后会产生binlog同步给A库,A库发现server_id一致则不同步</li>
<li>如何避免出现循环复制情况:比如三个节点,ABC,A-&gt;B B-&gt;C C-&gt;B当A同步数据过去是BC会出现循环同步问题</li>
</ul>
<h3 id="主从延时情况"><a href="#主从延时情况" class="headerlink" title="主从延时情况"></a>主从延时情况</h3><ol>
<li>主库DML语句并发大,从库qps高(通过gh-ost方案)</li>
<li>从库服务器配置差或者一台服务器上几台从库(资源竞争激烈,特别是io)</li>
<li>主库和从库的参数配置不一样</li>
<li>大事务,比如主库中事物执行10分钟那么从库则延时10分钟</li>
<li>从库上在进行备份操作,从库进行一致性读的备份,影响binlog日志的消费</li>
<li>表上无主键的情况(主库利用索引更改数据,备库回放只能用全表扫描,这种情况可以调整slave_rows_search_algorithms参数适当优化下)</li>
<li>设置的是延迟备库</li>
<li>备库空间不足的情况下</li>
</ol>
<h3 id="同步方案"><a href="#同步方案" class="headerlink" title="同步方案"></a>同步方案</h3><ol>
<li><p>半同步复制法：当写操作的时候让主库主从同步完之后再返回结果，这样读操作读取从库的时候永远是最新的数据  缺点：导致写操作过程缓慢 </p>
</li>
<li><p>强制读写操作都读取主库，没做到读写分离，从库七不到作用，主库的访问压力会很大 </p>
</li>
<li><p>通过消息中间件来完成，读和写的操作都通过中间件来进行路由，当读取主库的时候会设置一个key，key的有效期和主从同步完成的时候保持一致 这样从库进行数据读取的时候，key存在路由到主库 不存在路由到从库</p>
<p>优点：解决了主从不一致问题和主库访问压力问题  缺点：使用中间件对应的成本较高</p>
</li>
<li><p>讲中间件换成缓存,同上步骤 优点:解决了现有问题,开发成本低</p>
</li>
</ol>
<h1 id="14、自增主键"><a href="#14、自增主键" class="headerlink" title="14、自增主键"></a>14、自增主键</h1><h3 id="自增主键"><a href="#自增主键" class="headerlink" title="自增主键"></a>自增主键</h3><ol>
<li>innodb中自增值,保存在内存中,8.0之后自增值持久化(存储在<strong>redo log</strong>)</li>
<li>5.7之前,mysql重启后查询<strong>max(id)+1&#x3D;auto_id</strong></li>
<li>自增修改机制<ul>
<li>当插入一行数据id,为0,null或未指定值是,将<strong>auto_increment</strong>值当主键插入</li>
<li>当指定值时直接插入,比如插入为X,auto_increment&#x3D;Y,比较两者大小,当X&lt;Y,是自增值不变,否则修改为新的自增值</li>
<li>自增值生成算法:auto_increment_offset(起始值)+auto_increment_increment(步长)</li>
</ul>
</li>
<li>插入数据流程,先获取自增值,在插入当插入比如失败时自增id不回滚(提高并发若回滚则其他线程需要阻塞不然会获取到相同自增id)</li>
</ol>
<h3 id="自增锁优化"><a href="#自增锁优化" class="headerlink" title="自增锁优化"></a>自增锁优化</h3><ol>
<li><p>参数innodb_autoinc_lock_model</p>
<ul>
<li>0:语句结束则释放锁</li>
<li>1:普通insert,申请后直接释放;批量:insert….select,当语句批量插入完后才释放(可进行批量id申请)</li>
<li>2:所有都是申请完后释放</li>
</ul>
</li>
<li><p>批量自增id申请策略</p>
<ul>
<li><p>第一次申请,分配1个</p>
</li>
<li><p>1个用完后,同一个语句第二次申请,分配2….依次类推</p>
</li>
<li><pre><code class="sql">insert into t values(null, 1,1);
insert into t values(null, 2,2);
insert into t values(null, 3,3);
insert into t values(null, 4,4);
create table t2 like t;
insert into t2(c,d) select c,d from t;
insert into t2 values(null, 5,5); -- 结果:(8,5,5)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 主键长度</span><br><span class="line"></span><br><span class="line">1. 自增id在同步给从库时,此时要选择binlog为row模式在binlog中会记录主库插入数据的auto_increment_id值;如果为statement时记录的为dml语句可能由于执行先后顺序影响id和主库不一致</span><br><span class="line">2. 自增id为int类型:int长度为4个字节 一个字节8bit  对应长度为32位  如果有符号则区间未 -2^31-2^31-1 无符号则:2^32-1</span><br><span class="line">3. 不使用自增id时系统自动分配rowId,rowId是全局的,所有无主键的表共享这个id.代码中实现是8字节的无符号,我们在设计时给row_id为6个字节;从0到2^48-1.rowId写入到最大后则在从0开始,这样会覆盖之前的数据</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### insert锁</span><br><span class="line"></span><br><span class="line">1. insert ... select</span><br><span class="line"></span><br><span class="line">   ```sql</span><br><span class="line">   session A:</span><br><span class="line">   insert into t values(-1,-1,-1);</span><br><span class="line">   session B:</span><br><span class="line">   insert into t2(c,d) select (c,d) from t;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>此时执行session b时会对所有的区间都加上next-key lock,防止插入过程中数据不一致;binlog如果不为row导致的主从不一致</p>
</li>
</ul>
</li>
<li><p>insert 循环写入</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2(c,d)  (<span class="keyword">select</span> c<span class="operator">+</span><span class="number">1</span>, d <span class="keyword">from</span> t force index(c) <span class="keyword">order</span> <span class="keyword">by</span> c <span class="keyword">desc</span> limit <span class="number">1</span>); <span class="comment">--加锁区间 (3,4] (4,无穷) next-lock key</span></span><br><span class="line"><span class="comment">-- 执行流程,对t表c索引反向遍历取c=4的回表查询d,右间隙原则防止结果不一致锁(4,无穷)</span></span><br><span class="line"></span><br><span class="line">如果当插入的表未t时,此时会将所有区间锁住;防止插入遍历过程中有数据写入到值重复写入,并会用临时表存储t查询结果(<span class="number">1.</span>先全表扫描t到临时表,临时表选择一行数据)</span><br></pre></td></tr></table></figure>
</li>
<li><p>insert 唯一冲突</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>); <span class="comment">-- 唯一键重复  但此时会给(5,10]区间加next-lock key 读锁(防止其他事物对10这一行数据的删除)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>insert into … on duplicate key update</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">11</span>,<span class="number">10</span>,<span class="number">10</span>) <span class="keyword">on</span> duplicate key <span class="keyword">update</span> d<span class="operator">=</span><span class="number">100</span>; </span><br><span class="line"><span class="comment">-- 执行过程中如果唯一键重复则执行更新结果显示为row=2(insert和update都认为成功)</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="15、案例"><a href="#15、案例" class="headerlink" title="15、案例"></a>15、案例</h1><h3 id="binlog备份"><a href="#binlog备份" class="headerlink" title="binlog备份"></a>binlog备份</h3><ol>
<li>备份binlog是一天一次还是一周一次备份?</li>
<li>一周一次:假设每周周一备份数据,当周一还未备份本周数据时宕机.<strong>周日宕机需要拿上周的全备+周一到周日某个时间点的全部binlog日志</strong></li>
<li>一天一次:假设今天23点宕机,<strong>此时需要当天之前的全备+今天23的binlog</strong></li>
<li>结论:<ul>
<li>时间:一天一次吊打一周一次</li>
<li>数据可靠性:一天只用保证一天的binlog日志完整,一周需要前一周binlog日志和本周的所有</li>
</ul>
</li>
</ol>
<h3 id="备库备份数据主库执行DDL"><a href="#备库备份数据主库执行DDL" class="headerlink" title="备库备份数据主库执行DDL"></a>备库备份数据主库执行DDL</h3><ol>
<li>备份库流程<ol>
<li>show create table</li>
<li>保存表结构到文件中</li>
<li>select * from 表,查询表中所有数据</li>
<li>拼接insert语句</li>
<li>写入到文件中</li>
<li>提交事物</li>
<li>注意事项:mvcc不增对DDL语句,当表结构修改后read-view视图会多一列</li>
</ol>
</li>
<li>分析流程<ul>
<li>如果DDL的binlog日志在1之前到达,此时保存的表结构为最新数据,查询read-view字段最新,正常备份数据.主从数据保持一致</li>
<li>如果ddl在2和3之间到达,此时保存的数据库表结构为旧,查询sql字段多一个字段,此时会报错.备份失败</li>
<li>如果在3之后6之前到达,由于3进行DML查询后获取了MDL的读锁,此时DDL语句无法获取当前表的写锁阻塞,等待当前表备份完之后提交事物,MDL读锁释放,DDL可执行.现象:主库延迟</li>
<li>如果在6之后,此时不会阻塞,跟第一种情况保持一致</li>
</ul>
</li>
</ol>
<h3 id="delete数据"><a href="#delete数据" class="headerlink" title="delete数据"></a>delete数据</h3><ol>
<li><p>删除一个表的前10000个数据,如下三种操作</p>
</li>
<li><p>delete from 表 limit 10000</p>
<ol start="2">
<li>开启一个连接,进行20次delete from 表 limit 500</li>
<li>开启20个连接,每次delete from 表 limit 500</li>
</ol>
</li>
<li><p>分析:</p>
<ul>
<li>第一种操作,整个事物过程;此时如果其中一条数据被更新获取了当前行的行锁,此时delete操作阻塞,主从延时</li>
<li>第二个操作,正确答案.这样能降低每个事物的大小,删除其中一个数据段500,另外数据段被更新互不影响</li>
<li>第三个操作,开启20个连接,人为造成锁冲突</li>
</ul>
</li>
</ol>
<h3 id="随1取值优化"><a href="#随1取值优化" class="headerlink" title="随1取值优化"></a>随1取值优化</h3><ol>
<li>查询最大值:select max(id) from words</li>
<li>查询最小值:select min(id) from words</li>
<li>生成随机id:long randomId &#x3D; (max(id)-min(id))*random()+min(id)</li>
<li>随机选择1条数据:select id from words where id &gt;&#x3D; randomId limit 1</li>
</ol>
<h3 id="短连接风暴"><a href="#短连接风暴" class="headerlink" title="短连接风暴"></a>短连接风暴</h3><ol>
<li><p>场景:当数据库处理很慢时,连接会暴涨,会提示 too many connection</p>
</li>
<li><p>配置:max_connections:show VARIABLES like “%max_connection%”</p>
</li>
<li><p>解决方案</p>
<ul>
<li><p>处理占用连接不工作的线程</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> processlist; <span class="comment">-- 查看sleep对应的线程</span></span><br><span class="line"><span class="keyword">SELECT</span> trx_id,trx_mysql_thread_id <span class="keyword">from</span> INNODB_TRX <span class="comment">-- kill connection thread-id</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>减少连接过程的消耗<br>当出现短时间需要申请大量的连接时,此时可以去掉连接器的权限验证,通过–skip-grant-tables</p>
</li>
</ul>
</li>
</ol>
<h3 id="QPS突增"><a href="#QPS突增" class="headerlink" title="QPS突增"></a>QPS突增</h3><ol>
<li>可能由于新服务的上线,或者突然情况到值mysql表锁比如<strong>更新语句条件未添加索引,导致整个表行锁+间隙锁</strong></li>
<li>停用该服务对应的账号,将qps降为0但是会出现业务失败</li>
<li>将复杂的sql转为select 1</li>
<li>通过监控定期处理慢sql查询进行优化,分开配置账号和权限</li>
</ol>
<h3 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h3><ol>
<li><p>delete 语句误删行数据</p>
<ul>
<li>通过flashback恢复数据,流程根据binlog日志配置binlog_format&#x3D;row,如果当前事件是insert语句则转换为delete:id  update:更新旧数据回去 delete:insert 旧数据</li>
<li>此时操作不应该在主库直接执行,应该在主库备份一个备库后执行,防止对数据进行二次坏</li>
<li>当如果是delete全表的时候,此时通过undo log来回滚数据会很慢</li>
</ul>
</li>
<li><p>误删库&#x2F;表</p>
<ul>
<li><p>通过binlog日志恢复数据(数据拷贝)</p>
<ul>
<li>假设数据的备份是按天执行,此时假设当天23点宕机此时,需要取昨天0点备份的完备数据+今天到23点的binlog日志来恢复数据,binlog通过mysqldump来恢复</li>
</ul>
</li>
<li><p>延时复制备库</p>
<ul>
<li>当主库执行完sql语句后,设置备库和主库中同步间隔时间比如1小时,如果当进行了误操作时,此时通过备库来恢复数据</li>
</ul>
</li>
<li><p>账号权限控制</p>
<ul>
<li>控制账号的读写权限</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><ol>
<li>kill connection:断开客户端与服务端的连接</li>
<li>kill query:客户端与服务端的连接未断开,当前线程被标记为THD::KILL_QUERY,当线程在执行过程中某个锚点判断状态时线程终止</li>
<li>kill 退出不了的情况<ul>
<li>线程不能执行到判断线程状态逻辑:比如select sleep(1000) from 表,kill query thread等待,只能通过kill connection来断开</li>
<li>终止逻辑时间过长:超大事物被kill需要长时间的回滚和删除日志文件</li>
</ul>
</li>
<li>库中表多客户端连接慢<ul>
<li>-A:客户端不在去通过show tables来缓存数据表名称到客户端,这样查看表是不会有table提示</li>
<li>-quick<ul>
<li>客户端本地缓存,先将结果存起来,对应api mysql_store_result</li>
<li>读一个客户端处理一个,用api 对应mysql_use_result</li>
<li>quick作用:<ul>
<li>跳过表名自动补全</li>
<li>采用第二种方式不需要本地缓存,因为使用缓如果查询语句时间较长耗费较大的本地内存,影响客户端的性能</li>
<li>不会把执行命令记录到本地的命令历史文件中</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="16、数据库规范"><a href="#16、数据库规范" class="headerlink" title="16、数据库规范"></a>16、数据库规范</h1><h3 id="基本规范"><a href="#基本规范" class="headerlink" title="基本规范"></a>基本规范</h3><ol>
<li>表存储引擎InnoDB</li>
<li>表字符集:默认utf8 必要的时候使用utfmb4,理由如下:<ul>
<li>1.中文,无乱码风险 汉子存储3个字节,英文默认一个字节</li>
<li>uft8mb4是utf的超集,当有存储3个字节比如表情符号的时候使用</li>
</ul>
</li>
<li>禁止使用存储过程,视图,触发器,event 理由如下:<ul>
<li>对数据库性能影响很大</li>
<li>调试过程较复杂</li>
</ul>
</li>
<li>禁止在数据库存储大文件,比如照片 文件等应该存储对应的下载地址</li>
<li>禁止在线上数据库压测,压测应该有自己的功能测试或性能测试环境</li>
<li>每个环境的数据库必须隔离</li>
</ol>
<h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><ol>
<li>库名 表名 列名必须小写 采用下划线分割</li>
<li>库名和表名顾名思义</li>
<li>库数据备份以bak为前缀以日期为后缀</li>
<li>从库必须-s为后缀 备库必须-ss为后缀</li>
</ol>
<h3 id="表设计规范"><a href="#表设计规范" class="headerlink" title="表设计规范"></a>表设计规范</h3><ol>
<li>单实例表个数必须控制2000个以内</li>
<li>单表分表个数控制在1024个以内(阿里drds sharding&#x3D;256)</li>
<li>表必须要有主键,推荐使用无符号的整数位主键</li>
<li>禁止使用外键<ul>
<li>外键容易耦合数据影响sql语句的执行</li>
</ul>
</li>
<li>将大字段,访问频度低的字段拆分到单独的表中存储(通过垂直拆分的方式,分为主表和扩展表合理的使用数据库的缓存空间)理由:<ul>
<li>删除无主键的表,如果是row模式主从架构,从库会挂住</li>
</ul>
</li>
</ol>
<h3 id="列设计规范"><a href="#列设计规范" class="headerlink" title="列设计规范"></a>列设计规范</h3><ol>
<li>根据业务使用tinyint&#x2F;int&#x2F;bigint	分别对应java代码中的byte int Long 对应的字节数 1&#x2F;4&#x2F;8</li>
<li>根据业务区分char&#x2F;varchar 固定长度的使用char 可变长度使用varchar理由:<ul>
<li>固定长度使用char减少碎片空间</li>
</ul>
</li>
<li>根据业务区分使用datetime&#x2F;timestamp理由:<ul>
<li>datetime占用五个字节 存储年:year 日期:date 时间:datetime</li>
<li>timestamp占用4个字节</li>
</ul>
</li>
<li>必须把字段定位为not null 并设默认值理由:<ul>
<li>null列使用索引,索引统计,值更加的复杂</li>
<li>null需要更多的存储空间</li>
<li>null只能采用is null或者is not null 当在使用 &#x3D; &#x2F;!&#x3D;&#x2F;not in时有很多坑</li>
</ul>
</li>
<li>存储ip类型的比如ipv4通过 int存储不通过char(15)</li>
<li>使用varchar(20)存储手机号码,不通过整数理由:<ul>
<li>如果存在国家代码比如+86</li>
<li>手机号一般都是模糊查询不会用来数字计算</li>
</ul>
</li>
</ol>
<h3 id="索引规范"><a href="#索引规范" class="headerlink" title="索引规范"></a>索引规范</h3><ol>
<li>唯一索引使用uniq_字段名</li>
<li>非唯一索引使用idx_字段名来命名</li>
<li>单表索引的字段控制在5个以内理由:<ul>
<li>高并发的业务情况下,太多索引会影响写性能</li>
<li>当mysql去生成执行计划时,索引太多会降低性能,导致mysql选择不到最优的索引</li>
<li>较复杂的查询可以使用搜索引擎实现比如solr es</li>
</ul>
</li>
<li>组合索引字段建议不要超过五个(最左原则)理由:<ul>
<li>当使用五个字段还不能缩小row范围,数据库设计需要调整</li>
</ul>
</li>
<li>不建议在频繁更新的字段上家索引,写入数据性能降低</li>
<li>非必要情况别做join查询,如果要做必须保证字段数据类型一样并建立了索引</li>
</ol>
<h3 id="sql规范"><a href="#sql规范" class="headerlink" title="sql规范"></a>sql规范</h3><ol>
<li>禁止使用select * 只查询需要的字段理由:<ul>
<li>select * 会增减cpu&#x2F;io&#x2F;内存&#x2F;带宽的消耗</li>
<li>指定字段查询有利于使用覆盖索引</li>
<li>指定字段查询时当表结构变化时对程序的性能无影响</li>
</ul>
</li>
<li>insert必须指定字段 禁止使用 insert into 表 values() 应该使用 insert into 表(column1) value(column1value)<ul>
<li>当表结构发生变化时对程序无影响</li>
</ul>
</li>
<li>隐式类型的转换会使索引失效,导致全表查询 比如varchar类型的索引使用int查询 匹配值不知道前缀加多少位0</li>
<li>禁止在where条件使用函数或者表达式,导致不能命中索引全表查询</li>
<li>禁止负像查询比如%开发的模糊查询,尽量使用  abc%前缀模糊匹配不然会导致全表查询不能命中索引</li>
<li>禁止大表join和子查询</li>
<li>同一个字段的or必须改成in,in的值必须小于50个  在使用in的时候能命中索引</li>
<li>程序必须捕获sql异常</li>
</ol>
<h3 id="字段设计"><a href="#字段设计" class="headerlink" title="字段设计"></a>字段设计</h3><ol>
<li>bigint:-2^63~2^63-1的整型所有数  建表时显示的位数</li>
<li>tinyint:0-255的整形数据  占用一个字节   </li>
<li>int:占用4个字节  -2^31~~2^31-1</li>
<li>DECIMAL(M, D): M代表小数点右边的十进制的位数,D代表小数点的位数</li>
<li>char 1一个字节  长度是固定 0-255</li>
<li>varchar 两个字节  0-2^16-1 可变长度</li>
<li>datetime和timestamp区别?<ul>
<li>timestamp在存储时间的时候存储UTC时间国际时间;在查询的时候会将timestamp转成当前时区的时间.datetime不会做任何改变</li>
<li>timestamp存储时间的范围是:1970-01-01 00:00:01到2038-01-19i 03:14:07.9,datetime所能存储的时间范围是1000-01-01 00:00:00到9999-12-31 23:59:59</li>
<li>datetime存储的时候使用8字节存储;timestamp为4字节存储;timestamp比datetime的空间效率高</li>
<li>datetime的默认为null;timestamp的字段默认值不为空,为当前时间current_timestamp</li>
</ul>
</li>
</ol>
<h1 id="17、并发扣款"><a href="#17、并发扣款" class="headerlink" title="17、并发扣款"></a>17、并发扣款</h1><h3 id="如何保证数据一致性"><a href="#如何保证数据一致性" class="headerlink" title="如何保证数据一致性"></a>如何保证数据一致性</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">初始金额money<span class="operator">=</span><span class="number">100</span></span><br><span class="line"></span><br><span class="line">请求A扣款<span class="number">50</span>元:<span class="keyword">update</span> yue_table <span class="keyword">set</span> money <span class="operator">=</span> <span class="number">50</span> <span class="keyword">where</span> uid <span class="operator">=</span> $uid</span><br><span class="line">请求B扣款<span class="number">30</span>元:<span class="keyword">update</span> yue_table <span class="keyword">set</span> money <span class="operator">=</span> <span class="number">70</span> <span class="keyword">where</span> uid <span class="operator">=</span> $uid</span><br></pre></td></tr></table></figure>

<ol>
<li><p>如果两个更新语句存在并发最后数据的结果则可能有误,比如A先执行B后执行,最后金额为70元其本质为20元</p>
</li>
<li><p>通过cas来保证数据更新并发执行</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> yue_table <span class="keyword">set</span> money <span class="operator">=</span> <span class="number">50</span> <span class="keyword">where</span> uid <span class="operator">=</span> $uid <span class="keyword">and</span> money <span class="operator">=</span> $oldMoney</span><br><span class="line"><span class="keyword">update</span> yue_table <span class="keyword">set</span> money <span class="operator">=</span> <span class="number">70</span> <span class="keyword">where</span> uid <span class="operator">=</span> $uid <span class="keyword">and</span> money <span class="operator">=</span> $oldMoney</span><br></pre></td></tr></table></figure>
</li>
<li><p>当其中一条sql执行成功后,另外一条则更新失败因为money已经变更了,此时通过cas来保证数据一致性,当影响行数&#x3D;0时,则重试(select money 后在update),影响行数为1则更新成功</p>
</li>
<li><p>cas可能存在ABA问题</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">比如请求A:更新余额为A</span><br><span class="line">比如请求B:更新余额为B</span><br><span class="line">比如请求C:更新余额为A</span><br><span class="line">当B,C执行后A在去执行的时候,此时库中的A并不是自己之前查询出来的A,则即ABA问题</span><br><span class="line">当如果是栈的结构时,ABA则会有问题比如栈中存在两个相同元素</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过版本号解决ABA问题</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> money,version <span class="keyword">from</span> yue_table;</span><br><span class="line"><span class="keyword">update</span> yue_table <span class="keyword">set</span> money<span class="operator">=</span>$money ,version<span class="operator">=</span>$newVersion <span class="keyword">where</span> version<span class="operator">=</span>$version</span><br><span class="line">如果出现aba时,此时数据对应的版本号已经改变</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="接口幂等"><a href="#接口幂等" class="headerlink" title="接口幂等"></a>接口幂等</h3><p>为啥不执行money&#x3D;money-扣款,因为可能存在很多服务有重试机制</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> yue_table <span class="keyword">set</span> money<span class="operator">=</span>$money<span class="operator">-</span>扣减值 <span class="keyword">where</span> uid<span class="operator">=</span>$uid</span><br><span class="line">money<span class="operator">=</span>money<span class="operator">-</span>扣减值:语法保证操作的幂等,幂等即同一个接口执行多次结果一直,改操作则会扣减多</span><br></pre></td></tr></table></figure>

<h3 id="redis中保存余额"><a href="#redis中保存余额" class="headerlink" title="redis中保存余额"></a>redis中保存余额</h3><ol>
<li><p>redis的事物本质是乐观锁</p>
</li>
<li><p>redis 提供watch和exec</p>
<ul>
<li>watch观察key是否被改动</li>
<li>如果提交key被改动,exec将返回null,表示事物失败</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">watch <span class="type">key</span></span><br><span class="line"><span class="variable">$money</span> <span class="operator">=</span> get <span class="type">key</span></span><br><span class="line"><span class="variable">$money</span> <span class="operator">=</span> $money - $diff</span><br><span class="line">multi</span><br><span class="line">set key $money</span><br><span class="line">exec</span><br></pre></td></tr></table></figure>
</li>
<li><p>对比mysql而已</p>
<ul>
<li>redis可能存在数据丢失问题,此时需要结合redis的aof和rdb,如果每次写操作都落盘会降低redis性能</li>
<li>redis通过单线程来避免锁,mysql通过mvcc来快照读,更新数据通过锁来控制</li>
</ul>
</li>
</ol>
<h1 id="18、分库分表"><a href="#18、分库分表" class="headerlink" title="18、分库分表"></a>18、分库分表</h1><h3 id="1、为什么要分库分表"><a href="#1、为什么要分库分表" class="headerlink" title="1、为什么要分库分表?"></a>1、为什么要分库分表?</h3><ul>
<li>单表数据量过大,目前用户表数据2000w(复杂的sql查询较慢)</li>
<li>用户库中还存在其他表,导致整个库中数据量较大(数据库所在实例磁盘空间占用较大)</li>
</ul>
<h3 id="2、用过哪些分库分表的中间件"><a href="#2、用过哪些分库分表的中间件" class="headerlink" title="2、用过哪些分库分表的中间件?"></a>2、用过哪些分库分表的中间件?</h3><ul>
<li>mycat:基于数据库层分库分表即proxy,需要系统人员去维护和部署</li>
<li>sharding-jdbc(sharding-sphere)<br>基于client层,方便集成,只需要在调用过程中集合数据库中间件后就可以将数据存储到指定的库和表中数据</li>
</ul>
<h3 id="3、库的拆分是垂直还是水平-分库还是分表"><a href="#3、库的拆分是垂直还是水平-分库还是分表" class="headerlink" title="3、库的拆分是垂直还是水平,分库还是分表?"></a>3、库的拆分是垂直还是水平,分库还是分表?</h3><ul>
<li>水平分表:将user单表中的数据水平拆分成user_0,user_1,user_2,…每个表的结构一样,比如user表2000w数据,水平拆分20个表,拆分完之后单表的数据为100w.(整个sql的查询从2s,变成100ms)</li>
<li>水平分库:将user库中的数据进行拆分,拆分成user_0库,user_1库….,比如user库中2000w条数据,水平分库后每个库中存储100w数据,每个库的表名和表接口相同</li>
<li>垂直分表:将user表中的数据比如有字段 id,name,age,city,phone…..等,将user表拆分为user,user_ext(扩展表中存储一些扩展字段),不允许两个表联表查询  先查询user表后在查询user_ext表,提高单表的查询效率</li>
<li>垂直分库:根据不同的业务进行库的划分,比如现在库a中有用户表user,订单表order,此时根据业务进行划分降低库a的单库存储的数据量</li>
</ul>
<h3 id="4、将当前系统中单库单表的系统-未来进行分库分表-如何切换"><a href="#4、将当前系统中单库单表的系统-未来进行分库分表-如何切换" class="headerlink" title="4、将当前系统中单库单表的系统,未来进行分库分表,如何切换?"></a>4、将当前系统中单库单表的系统,未来进行分库分表,如何切换?</h3><ol>
<li>停机切换<ul>
<li>编写临时程序将单库单表的旧数据取出写入数据库中间件中,数据库中间件分配到指定的分库和分表中;将分库分表的逻辑代码部署(修改配置信息,测试后上线)</li>
<li>存在问题:<ul>
<li>当单库单表的数据量很大的时候,可能临时程序拉去数据就要3.4个小时,当天可能写不到新库中</li>
<li>出现问题后,不能影响明天生产需要回滚代码,第二天网上在重试,这样开发人员和dba等相关人员会很累</li>
</ul>
</li>
</ul>
</li>
<li>不停机,双写切换<ul>
<li>修改写入单库单表的代码,实现双写<ul>
<li>写入旧库逻辑保证不变 </li>
<li>写入数据库中间件中分发到对应的分库分表中</li>
<li>此时线下数据库双写,记录双写程序上线之前的时间,编写临时程序拉去记录时间之前的数据.写入到分库分表中间件中,写入数据时做数据校验.判断当前数据是否在分库分表中存在,存在则判断时间旧库新则更新分库分表,不存在则写入到分库分表(当程序跑个几天之后数据肯定是对的上了,此时在切换为分库分表对应的库)</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li><p><input disabled="" type="checkbox"> 
如何设计可以动态扩容缩容的分库分表方案?<br>参考标准:32个库 32个表  32<em>32 &#x3D; 1024   假设一个表中存储1000w数据,此时  1024</em>1000w&#x3D;102亿数据<br>32个库可以存储在4台机器中,每台机器8个实例. 每个实例32张表<br>动态扩容:分库分表的大小不变,保持32个库32个表;如果是当前机器磁盘不够存储,此时添加为8台机器,每台机器4个实例,每个实例32张表降低单台机器的磁盘;如果是当前库中存储数据量过大,此时可以将实例上的表进行拆分,比如16台机器 每台机器4个实例每个实例16张表来降低单个库数据量.此时都只需要修改sharding-jdbc的配置信息</p>
</li>
<li><p><input disabled="" type="checkbox"> 
分库分表之后,id键怎么生成?</p>
<ol>
<li><p>全局表,主键id自动生成<br>原理:当插入到分库分表中时,先通过全局表主键自增生成id后在存储到分库分表中</p>
<p>使用场景:并发量较小情况</p>
</li>
<li><p>UUID<br>原理:根据UUID生成不同的id,存储到分库分表中<br>使用场景:非主键字段时,因为UUID长度较长,在innodb中每个普通索引的叶子节点下都存储则主键索引,这样索引存储很浪费磁盘空间</p>
</li>
<li><p>时间磋+其他+id<br>原理:时间磋比如当前时间(201911142027+用户id+自增6位id),该id从redis中自增比如刚开为000001,设置redis中id每天凌晨来重置为00001</p>
</li>
<li><p>雪花算法snowflake<br>原理:64位的long类型,对应的字节长度为64位<br>第一位:0  代表符号位:正数<br>第二位:41位  代表当前时间毫秒时间磋:对应的二进制值<br>第三位:5位 机房id<br>第四位:5位 机器id<br>第五位:12   序列id,如果是同一时间同一机房同一机器并发的问题,从0开始  最多同一毫秒内四千多少来个,对应的qps可以达到4000&#x2F;ms  4000*1000&#x2F;s  400w&#x2F;s</p>
</li>
</ol>
</li>
<li><p><input disabled="" type="checkbox"> 
用户中心的分库分表,sharding-jdbc?</p>
<ol>
<li><p>单库容量:1500w</p>
</li>
<li><p>假设分8片,1500*8&#x3D;1.2亿</p>
</li>
<li><p>8片分两个库中存储,每个库存储4张表比如usercenter01,usercenter02  usercenter01:user_0 user_1 user_2 user_3,usercenter02:user_4,user_5,user_6,user_7</p>
</li>
<li><p>数据源对应的连接存储和表对应的数据库存储,记录在表中(一旦分片分片片数则不开变)</p>
<ol>
<li><p>分库数据库的索引表(库的名称和库信息)<br>CREATE TABLE <code>db_sharding_config</code> (<br><code>id</code> int(11) NOT NULL AUTO_INCREMENT COMMENT ‘自增id’,<br><code>db_index</code> int(11) NOT NULL COMMENT ‘数据库的名称的索引。index，比如，分了4个库。则 index 分别是0，1，2，3。构成的物理库名就是 db0,db1,db2,db3’,<br><code>db_url</code> varchar(50) NOT NULL COMMENT ‘数据库对应的url’,<br><code>db_username</code> varchar(20) DEFAULT NULL COMMENT ‘数据库用户名，可以为null，为null则代表db由应用程序其他地方控制（处于信息安全考虑）’,<br><code>db_password</code> varchar(50) DEFAULT NULL COMMENT ‘数据库密码。可以为null，null则代表应用程序从其他地方加载配置（出于信息安全考虑）’,<br><code>db_poolsize</code> int(11) DEFAULT NULL COMMENT ‘数据库连接池大小。可以为null，为null则代表外部统一配置’,<br><code>db_logic_name</code> varchar(20) NOT NULL COMMENT ‘逻辑数据库名。与dbindex构成物理数据库名’,<br>PRIMARY KEY (<code>id</code>)<br>) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;3 DEFAULT CHARSET&#x3D;utf8 COMMENT&#x3D;’分库数据库索引表’;<br>![image-20191118164715525](&#x2F;Users&#x2F;zhouzhihui&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20191118164715525.png)</p>
</li>
<li><p>分库基础数据表<br>CREATE TABLE <code>user_sharding_item</code> (<br><code>id</code> int(11) NOT NULL AUTO_INCREMENT COMMENT ‘主键递增’,<br><code>logic_tablename</code> varchar(100) NOT NULL COMMENT ‘逻辑表名，比如userinfocenter。则真实的表名 和数据库分片一一对应。比如 userinfocenter_0，userinfocenter_1 这样。’,<br><code>sharding_column</code> varchar(11) NOT NULL COMMENT ‘分片键’,<br><code>sharding_count</code> int(11) NOT NULL COMMENT ‘该分表需要的分片总数。此值一旦设置，不可再更改。’,<br>PRIMARY KEY (<code>id</code>)<br>) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;2 DEFAULT CHARSET&#x3D;utf8 COMMENT&#x3D;’分库基础数据表’;</p>
<p><img src="/%5Cimages%5Cimage-20191118164857651.png" alt="image-20191118164857651"></p>
</li>
<li><p>分片和数据库id对应关系表<br>CREATE TABLE <code>user_table_sharding_config</code> (</p>
<p><code>id</code> int(11) NOT NULL AUTO_INCREMENT COMMENT ‘自增id’,<br><code>sharding_id</code> int(11) NOT NULL COMMENT ‘分片id’,<br><code>db_index</code> varchar(100) NOT NULL COMMENT ‘该分片所属的db_index。注意不是主键’,<br><code>sharding_item_id</code> int(11) NOT NULL COMMENT ‘关联的sharding_item表的id’,<br>PRIMARY KEY (<code>id</code>)<br>) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;9 DEFAULT CHARSET&#x3D;utf8 COMMENT&#x3D;’分片和数据库id对应关系表’;</p>
</li>
</ol>
</li>
</ol>
<p>![image-20191118165103269](&#x2F;Users&#x2F;zhouzhihui&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20191118165103269.png)</p>
<pre><code>   4. 全局唯一id
    CREATE TABLE `id_generator` (

    ### 分库分表
    
    - [ ] 为什么要分库分表?
    
      1. 单表数据量过大,目前用户表数据2000w(复杂的sql查询较慢)
      2. 用户库中还存在其他表,导致整个库中数据量较大(数据库所在实例磁盘空间占用较大)
    
    - [ ] 用过哪些分库分表的中间件?
    
      1. mycat
         基于数据库层分库分表即proxy,需要系统人员去维护和部署
2. sharding-jdbc(sharding-sphere)
     基于client层,方便集成,只需要在调用过程中集合数据库中间件后就可以将数据存储到指定的库和表中

- [ ] 数据库的拆分是垂直还是水平,分库还是分表?

  1. 水平分表:将user单表中的数据水平拆分成user_0,user_1,user_2,...每个表的结构一样,比如user表2000w数据,水平拆分20个表,拆分完之后单表的数据为100w.(整个sql的查询从2s,变成100ms)
  2. 水平分库:将user库中的数据进行拆分,拆分成user_0库,user_1库....,比如user库中2000w条数据,水平分库后每个库中存储100w数据,每个库的表名和表接口相同
  3. 垂直分表:将user表中的数据比如有字段 id,name,age,city,phone.....等,将user表拆分为user,user_ext(扩展表中存储一些扩展字段),不允许两个表联表查询  先查询user表后在查询user_ext表,提高单表的查询效率
  4. 垂直分库:根据不同的业务进行库的划分,比如现在库a中有用户表user,订单表order,此时根据业务进行划分降低库a的单库存储的数据量

- [ ] 将当前系统中单库单表的系统,未来进行分库分表,如何切换?

  1. 停机切换
     编写临时程序将单库单表的旧数据取出写入数据库中间件中,数据库中间件分配到指定的分库和分表中;

     将分库分表的逻辑代码部署(修改配置信息,测试后上线)
     存在问题:

     1. 当单库单表的数据量很大的时候,可能临时程序拉去数据就要3.4个小时,当天可能写不到新库中
     2. 出现问题后,不能影响明天生产需要回滚代码,第二天网上在重试,这样开发人员和dba等相关人员会很累

  2. 不停机,双写切换
     修改写入单库单表的代码,实现双写

     1. 写入旧库逻辑保证不变 
     2. 写入数据库中间件中分发到对应的分库分表中
     3. 此时线下数据库双写,记录双写程序上线之前的时间,编写临时程序拉去记录时间之前的数据.写入到分库分表中间件中,写入数据时做数据校验.判断当前数据是否在分库分表中存在,存在则判断时间旧库新则更新分库分表,不存在则写入到分库分表(当程序跑个几天之后数据肯定是对的上了,此时在切换为分库分表对应的库)

- [ ] 如何设计可以动态扩容缩容的分库分表方案?
  参考标准:32个库 32个表  32*32 = 1024   假设一个表中存储1000w数据,此时  1024*1000w=102亿数据
  32个库可以存储在4台机器中,每台机器8个实例. 每个实例32张表
  动态扩容:分库分表的大小不变,保持32个库32个表;如果是当前机器磁盘不够存储,此时添加为8台机器,每台机器4个实例,每个实例32张表降低单台机器的磁盘;如果是当前库中存储数据量过大,此时可以将实例上的表进行拆分,比如16台机器 每台机器4个实例每个实例16张表来降低单个库数据量.此时都只需要修改sharding-jdbc的配置信息

- [ ] 分库分表之后,id键怎么生成?

  1. 全局表,主键id自动生成
     原理:当插入到分库分表中时,先通过全局表主键自增生成id后在存储到分库分表中

     使用场景:并发量较小情况

  2. UUID
     原理:根据UUID生成不同的id,存储到分库分表中
     使用场景:非主键字段时,因为UUID长度较长,在innodb中每个普通索引的叶子节点下都存储则主键索引,这样索引存储很浪费磁盘空间

  3. 时间磋+其他+id
     原理:时间磋比如当前时间(201911142027+用户id+自增6位id),该id从redis中自增比如刚开为000001,设置redis中id每天凌晨来重置为00001

  4. 雪花算法snowflake
     原理:64位的long类型,对应的字节长度为64位
     第一位:0  代表符号位:正数
     第二位:41位  代表当前时间毫秒时间磋:对应的二进制值
     第三位:5位 机房id
     第四位:5位 机器id
     第五位:12   序列id,如果是同一时间同一机房同一机器并发的问题,从0开始  最多同一毫秒内四千多少来个,对应的qps可以达到4000/ms  4000*1000/s  400w/s

- [ ] 用户中心的分库分表,sharding-jdbc?

  1. 单库容量:1500w

  2. 假设分8片,1500*8=1.2亿

  3. 8片分两个库中存储,每个库存储4张表比如usercenter01,usercenter02  usercenter01:user_0 user_1 user_2 user_3,usercenter02:user_4,user_5,user_6,user_7

  4. 数据源对应的连接存储和表对应的数据库存储,记录在表中(一旦分片分片片数则不开变)

     1. 分库数据库的索引表(库的名称和库信息)
        CREATE TABLE `db_sharding_config` (
          `id` int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;自增id&#39;,
          `db_index` int(11) NOT NULL COMMENT &#39;数据库的名称的索引。index，比如，分了4个库。则 index 分别是0，1，2，3。构成的物理库名就是 db0,db1,db2,db3&#39;,
          `db_url` varchar(50) NOT NULL COMMENT &#39;数据库对应的url&#39;,
          `db_username` varchar(20) DEFAULT NULL COMMENT &#39;数据库用户名，可以为null，为null则代表db由应用程序其他地方控制（处于信息安全考虑）&#39;,
          `db_password` varchar(50) DEFAULT NULL COMMENT &#39;数据库密码。可以为null，null则代表应用程序从其他地方加载配置（出于信息安全考虑）&#39;,
          `db_poolsize` int(11) DEFAULT NULL COMMENT &#39;数据库连接池大小。可以为null，为null则代表外部统一配置&#39;,
          `db_logic_name` varchar(20) NOT NULL COMMENT &#39;逻辑数据库名。与dbindex构成物理数据库名&#39;,
          PRIMARY KEY (`id`)
        ) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8 COMMENT=&#39;分库数据库索引表&#39;;
        ![image-20191118164715525](/Users/zhouzhihui/Library/Application Support/typora-user-images/image-20191118164715525.png)

     2. 分库基础数据表
        CREATE TABLE `user_sharding_item` (
          `id` int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;主键递增&#39;,
          `logic_tablename` varchar(100) NOT NULL COMMENT &#39;逻辑表名，比如userinfocenter。则真实的表名 和数据库分片一一对应。比如 userinfocenter_0，userinfocenter_1 这样。&#39;,
          `sharding_column` varchar(11) NOT NULL COMMENT &#39;分片键&#39;,
          `sharding_count` int(11) NOT NULL COMMENT &#39;该分表需要的分片总数。此值一旦设置，不可再更改。&#39;,
          PRIMARY KEY (`id`)
        ) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8 COMMENT=&#39;分库基础数据表&#39;;

        ![image-20191118164857651](/Users/zhouzhihui/Library/Application Support/typora-user-images/image-20191118164857651.png)

     3. 分片和数据库id对应关系表
        CREATE TABLE `user_table_sharding_config` (
          `id` int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;自增id&#39;,
          `sharding_id` int(11) NOT NULL COMMENT &#39;分片id&#39;,
          `db_index` varchar(100) NOT NULL COMMENT &#39;该分片所属的db_index。注意不是主键&#39;,
          `sharding_item_id` int(11) NOT NULL COMMENT &#39;关联的sharding_item表的id&#39;,
          PRIMARY KEY (`id`)
        ) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8 COMMENT=&#39;分片和数据库id对应关系表&#39;;

        ![image-20191118165103269](/Users/zhouzhihui/Library/Application Support/typora-user-images/image-20191118165103269.png)

     4. 全局唯一id
        CREATE TABLE `id_generator` (
          `id` int(11) NOT NULL AUTO_INCREMENT,
          `logictable` varchar(255) DEFAULT NULL COMMENT &#39;逻辑表名&#39;,
          `max_id` int(11) DEFAULT &#39;0&#39; COMMENT &#39;当前最大值&#39;,
          `step` int(11) DEFAULT NULL COMMENT &#39;每次生成id数&#39;,
          `update_time` datetime DEFAULT NULL COMMENT &#39;更新时间&#39;,
          `version` int(11) DEFAULT &#39;1&#39; COMMENT &#39;版本号，用于每次CAS更新max_id值&#39;,
          PRIMARY KEY (`id`)
        ) ENGINE=InnoDB DEFAULT CHARSET=utf8;
        id的步长区间未1000,比如max_id等于1000  说明:有客户端取了1-1000的元素
        比如max_id等于2000 即有取了  1001-2000的id
        每次取完之后的id放入到redis缓存队列中,定期检查比如90%
        每次取步长时即  update `id_generator` set max_id = 3000,version=2 where version=1
        更新完后同时更新version版本号,如果影响行数为0重试

     5. 参考地址:https://note.youdao.com/ynoteshare1/index.html?id=23e54bab22ef9499266861d661fa281a&amp;type=note
</code></pre>
<p>  ) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;<br>  id的步长区间未1000,比如max_id等于1000  说明:有客户端取了1-1000的元素<br>  比如max_id等于2000 即有取了  1001-2000的id<br>  每次取完之后的id放入到redis缓存队列中,定期检查比如90%<br>  每次取步长时即  update <code>id_generator</code> set max_id &#x3D; 3000,version&#x3D;2 where version&#x3D;1<br>  更新完后同时更新version版本号,如果影响行数为0重试</p>
</li>
</ul>
<h3 id="5、分库分表实现、读写分离："><a href="#5、分库分表实现、读写分离：" class="headerlink" title="5、分库分表实现、读写分离："></a>5、分库分表实现、读写分离：</h3><p>（1）为什么要分库分表（设计高并发系统的时候，数据库层面该如何设计）？用过哪些分库分表中间件？不同的分库分表中间件都有什么优点和缺点？你们具体是如何对数据库如何进行垂直拆分或水平拆分的？</p>
<p>（2）现在有一个未分库分表的系统，未来要分库分表，如何设计才可以让系统从未分库分表动态切换到分库分表上？</p>
<p>（3）如何设计可以动态扩容缩容的分库分表方案？</p>
<p>（4）分库分表之后，id主键如何处理？</p>
<hr>
<hr>
<p>1、面试题</p>
<p>为什么要分库分表（设计高并发系统的时候，数据库层面该如何设计）？用过哪些分库分表中间件？不同的分库分表中间件都有什么优点和缺点？你们具体是如何对数据库如何进行垂直拆分或水平拆分的？</p>
<p>2、面试官心里分析</p>
<p>其实这块肯定是扯到高并发了，因为分库分表一定是为了支撑高并发、数据量大两个问题的。而且现在说实话，尤其是互联网类的公司面试，基本上都会来这么一下，分库分表如此普遍的技术问题，不问实在是不行，而如果你不知道那也实在是说不过去！</p>
<p>3、面试题剖析</p>
<p>（1）为什么要分库分表？（设计高并发系统的时候，数据库层面该如何设计？）</p>
<p>说白了，分库分表是两回事儿，大家可别搞混了，可能是光分库不分表，也可能是光分表不分库，都有可能。我先给大家抛出来一个场景。</p>
<p>假如我们现在是一个小创业公司（或者是一个BAT公司刚兴起的一个新部门），现在注册用户就20万，每天活跃用户就1万，每天单表数据量就1000，然后高峰期每秒钟并发请求最多就10。。。天，就这种系统，随便找一个有几年工作经验的，然后带几个刚培训出来的，随便干干都可以。</p>
<p>结果没想到我们运气居然这么好，碰上个CEO带着我们走上了康庄大道，业务发展迅猛，过了几个月，注册用户数达到了2000万！每天活跃用户数100万！每天单表数据量10万条！高峰期每秒最大请求达到1000！同时公司还顺带着融资了两轮，紧张了几个亿人民币啊！公司估值达到了惊人的几亿美金！这是小独角兽的节奏！</p>
<p>好吧，没事，现在大家感觉压力已经有点大了，为啥呢？因为每天多10万条数据，一个月就多300万条数据，现在咱们单表已经几百万数据了，马上就破千万了。但是勉强还能撑着。高峰期请求现在是1000，咱们线上部署了几台机器，负载均衡搞了一下，数据库撑1000 QPS也还凑合。但是大家现在开始感觉有点担心了，接下来咋整呢。。。。。。</p>
<p>再接下来几个月，我的天，CEO太牛逼了，公司用户数已经达到1亿，公司继续融资几十亿人民币啊！公司估值达到了惊人的几十亿美金，成为了国内今年最牛逼的明星创业公司！天，我们太幸运了。</p>
<p>但是我们同时也是不幸的，因为此时每天活跃用户数上千万，每天单表新增数据多达50万，目前一个表总数据量都已经达到了两三千万了！扛不住啊！数据库磁盘容量不断消耗掉！高峰期并发达到惊人的5000~8000！别开玩笑了，哥。我跟你保证，你的系统支撑不到现在，已经挂掉了！</p>
<p>好吧，所以看到你这里你差不多就理解分库分表是怎么回事儿了，实际上这是跟着你的公司业务发展走的，你公司业务发展越好，用户就越多，数据量越大，请求量越大，那你单个数据库一定扛不住。</p>
<p>比如你单表都几千万数据了，你确定你能抗住么？绝对不行，单表数据量太大，会极大影响你的sql执行的性能，到了后面你的sql可能就跑的很慢了。一般来说，就以我的经验来看，单表到几百万的时候，性能就会相对差一些了，你就得分表了。</p>
<p>分表是啥意思？就是把一个表的数据放到多个表中，然后查询的时候你就查一个表。比如按照用户id来分表，将一个用户的数据就放在一个表中。然后操作的时候你对一个用户就操作那个表就好了。这样可以控制每个表的数据量在可控的范围内，比如每个表就固定在200万以内。</p>
<p>分库是啥意思？就是你一个库一般我们经验而言，最多支撑到并发2000，一定要扩容了，而且一个健康的单库并发值你最好保持在每秒1000左右，不要太大。那么你可以将一个库的数据拆分到多个库中，访问的时候就访问一个库好了。</p>
<p>这就是所谓的分库分表，为啥要分库分表？你明白了吧</p>
<p>（2）用过哪些分库分表中间件？不同的分库分表中间件都有什么优点和缺点？</p>
<p>这个其实就是看看你了解哪些分库分表的中间件，各个中间件的优缺点是啥？然后你用过哪些分库分表的中间件。</p>
<p>比较常见的包括：cobar、TDDL、atlas、sharding-jdbc、mycat</p>
<p>cobar：阿里b2b团队开发和开源的，属于proxy层方案。早些年还可以用，但是最近几年都没更新了，基本没啥人用，差不多算是被抛弃的状态吧。而且不支持读写分离、存储过程、跨库join和分页等操作。</p>
<p>TDDL：淘宝团队开发的，属于client层方案。不支持join、多表查询等语法，就是基本的crud语法是ok，但是支持读写分离。目前使用的也不多，因为还依赖淘宝的diamond配置管理系统。</p>
<p>atlas：360开源的，属于proxy层方案，以前是有一些公司在用的，但是确实有一个很大的问题就是社区最新的维护都在5年前了。所以，现在用的公司基本也很少了。</p>
<p>sharding-jdbc：当当开源的，属于client层方案。确实之前用的还比较多一些，因为SQL语法支持也比较多，没有太多限制，而且目前推出到了2.0版本，支持分库分表、读写分离、分布式id生成、柔性事务（最大努力送达型事务、TCC事务）。而且确实之前使用的公司会比较多一些（这个在官网有登记使用的公司，可以看到从2017年一直到现在，是不少公司在用的），目前社区也还一直在开发和维护，还算是比较活跃，个人认为算是一个现在也可以选择的方案。</p>
<p>mycat：基于coba改造的，属于proxy层方案，支持的功能非常完善，而且目前应该是非常火的而且不断流行的数据库中间件，社区很活跃，也有一些公司开始在用了。但是确实相比于sharding jdbc来说，年轻一些，经历的锤炼少一些。</p>
<p>所以综上所述，现在其实建议考量的，就是sharding-jdbc和mycat，这两个都可以去考虑使用。</p>
<p>sharding-jdbc这种client层方案的优点在于不用部署，运维成本低，不需要代理层的二次转发请求，性能很高，但是如果遇到升级啥的需要各个系统都重新升级版本再发布，各个系统都需要耦合sharding-jdbc的依赖；</p>
<p>mycat这种proxy层方案的缺点在于需要部署，自己及运维一套中间件，运维成本高，但是好处在于对于各个项目是透明的，如果遇到升级之类的都是自己中间件那里搞就行了。</p>
<p>通常来说，这两个方案其实都可以选用，但是我个人建议中小型公司选用sharding-jdbc，client层方案轻便，而且维护成本低，不需要额外增派人手，而且中小型公司系统复杂度会低一些，项目也没那么多；</p>
<p>但是中大型公司最好还是选用mycat这类proxy层方案，因为可能大公司系统和项目非常多，团队很大，人员充足，那么最好是专门弄个人来研究和维护mycat，然后大量项目直接透明使用即可。</p>
<p>我们，数据库中间件都是自研的，也用过proxy层，后来也用过client层</p>
<p>（3）你们具体是如何对数据库如何进行垂直拆分或水平拆分的？</p>
<p>水平拆分的意思，就是把一个表的数据给弄到多个库的多个表里去，但是每个库的表结构都一样，只不过每个库表放的数据是不同的，所有库表的数据加起来就是全部数据。水平拆分的意义，就是将数据均匀放更多的库里，然后用多个库来抗更高的并发，还有就是用多个库的存储容量来进行扩容。</p>
<p>垂直拆分的意思，就是把一个有很多字段的表给拆分成多个表，或者是多个库上去。每个库表的结构都不一样，每个库表都包含部分字段。一般来说，会将较少的访问频率很高的字段放到一个表里去，然后将较多的访问频率很低的字段放到另外一个表里去。因为数据库是有缓存的，你访问频率高的行字段越少，就可以在缓存里缓存更多的行，性能就越好。这个一般在表层面做的较多一些。</p>
<p>这个其实挺常见的，不一定我说，大家很多同学可能自己都做过，把一个大表拆开，订单表、订单支付表、订单商品表。</p>
<p>还有表层面的拆分，就是分表，将一个表变成N个表，就是让每个表的数据量控制在一定范围内，保证SQL的性能。否则单表数据量越大，SQL性能就越差。一般是200万行左右，不要太多，但是也得看具体你怎么操作，也可能是500万，或者是100万。你的SQL越复杂，就最好让单表行数越少。</p>
<p>好了，无论是分库了还是分表了，上面说的那些数据库中间件都是可以支持的。就是基本上那些中间件可以做到你分库分表之后，中间件可以根据你指定的某个字段值，比如说userid，自动路由到对应的库上去，然后再自动路由到对应的表里去。</p>
<p>你就得考虑一下，你的项目里该如何分库分表？一般来说，垂直拆分，你可以在表层面来做，对一些字段特别多的表做一下拆分；水平拆分，你可以说是并发承载不了，或者是数据量太大，容量承载不了，你给拆了，按什么字段来拆，你自己想好；分表，你考虑一下，你如果哪怕是拆到每个库里去，并发和容量都ok了，但是每个库的表还是太大了，那么你就分表，将这个表分开，保证每个表的数据量并不是很大。</p>
<p>而且这儿还有两种分库分表的方式，一种是按照range来分，就是每个库一段连续的数据，这个一般是按比如时间范围来的，但是这种一般较少用，因为很容易产生热点问题，大量的流量都打在最新的数据上了；或者是按照某个字段hash一下均匀分散，这个较为常用。</p>
<p>range来分，好处在于说，后面扩容的时候，就很容易，因为你只要预备好，给每个月都准备一个库就可以了，到了一个新的月份的时候，自然而然，就会写新的库了；缺点，但是大部分的请求，都是访问最新的数据。实际生产用range，要看场景，你的用户不是仅仅访问最新的数据，而是均匀的访问现在的数据以及历史的数据</p>
<p>hash分法，好处在于说，可以平均分配每个库的数据量和请求压力；坏处在于说扩容起来比较麻烦，会有一个数据迁移的这么一个过程</p>
<hr>
<hr>
<p>1、面试题</p>
<p>你们有没有做MySQL读写分离？如何实现mysql的读写分离？MySQL主从复制原理的是啥？如何解决mysql主从同步的延时问题？</p>
<p>2、面试官心里分析</p>
<p>这个，高并发这个阶段，那肯定是需要做读写分离的，啥意思？因为实际上大部分的互联网公司，一些网站，或者是app，其实都是读多写少。所以针对这个情况，就是写一个主库，但是主库挂多个从库，然后从多个从库来读，那不就可以支撑更高的读并发压力了吗？</p>
<p>3、面试题剖析</p>
<p>（1）如何实现mysql的读写分离？</p>
<p>其实很简单，就是基于主从复制架构，简单来说，就搞一个主库，挂多个从库，然后我们就单单只是写主库，然后主库会自动把数据给同步到从库上去。</p>
<p>（2）MySQL主从复制原理的是啥？</p>
<p>主库将变更写binlog日志，然后从库连接到主库之后，从库有一个IO线程，将主库的binlog日志拷贝到自己本地，写入一个中继日志中。接着从库中有一个SQL线程会从中继日志读取binlog，然后执行binlog日志中的内容，也就是在自己本地再次执行一遍SQL，这样就可以保证自己跟主库的数据是一样的。</p>
<p>这里有一个非常重要的一点，就是从库同步主库数据的过程是串行化的，也就是说主库上并行的操作，在从库上会串行执行。所以这就是一个非常重要的点了，由于从库从主库拷贝日志以及串行执行SQL的特点，在高并发场景下，从库的数据一定会比主库慢一些，是有延时的。所以经常出现，刚写入主库的数据可能是读不到的，要过几十毫秒，甚至几百毫秒才能读取到。</p>
<p>而且这里还有另外一个问题，就是如果主库突然宕机，然后恰好数据还没同步到从库，那么有些数据可能在从库上是没有的，有些数据可能就丢失了。</p>
<p>所以mysql实际上在这一块有两个机制，一个是半同步复制，用来解决主库数据丢失问题；一个是并行复制，用来解决主从同步延时问题。</p>
<p>这个所谓半同步复制，semi-sync复制，指的就是主库写入binlog日志之后，就会将强制此时立即将数据同步到从库，从库将日志写入自己本地的relay log之后，接着会返回一个ack给主库，主库接收到至少一个从库的ack之后才会认为写操作完成了。</p>
<p>所谓并行复制，指的是从库开启多个线程，并行读取relay log中不同库的日志，然后并行重放不同库的日志，这是库级别的并行。</p>
<p>1）主从复制的原理</p>
<p>2）主从延迟问题产生的原因</p>
<p>3）主从复制的数据丢失问题，以及半同步复制的原理</p>
<p>4）并行复制的原理，多库并发重放relay日志，缓解主从延迟问题</p>
<p>（3）mysql主从同步延时问题（精华）</p>
<p>线上确实处理过因为主从同步延时问题，导致的线上的bug，小型的生产事故</p>
<p>show status，Seconds_Behind_Master，你可以看到从库复制主库的数据落后了几ms</p>
<p>其实这块东西我们经常会碰到，就比如说用了mysql主从架构之后，可能会发现，刚写入库的数据结果没查到，结果就完蛋了。。。。</p>
<p>所以实际上你要考虑好应该在什么场景下来用这个mysql主从同步，建议是一般在读远远多于写，而且读的时候一般对数据时效性要求没那么高的时候，用mysql主从同步</p>
<p>所以这个时候，我们可以考虑的一个事情就是，你可以用mysql的并行复制，但是问题是那是库级别的并行，所以有时候作用不是很大</p>
<p>所以这个时候。。通常来说，我们会对于那种写了之后立马就要保证可以查到的场景，采用强制读主库的方式，这样就可以保证你肯定的可以读到数据了吧。其实用一些数据库中间件是没问题的。</p>
<p>一般来说，如果主从延迟较为严重</p>
<p>1、分库，将一个主库拆分为4个主库，每个主库的写并发就500&#x2F;s，此时主从延迟可以忽略不计</p>
<p>2、打开mysql支持的并行复制，多个库并行复制，如果说某个库的写入并发就是特别高，单库写并发达到了2000&#x2F;s，并行复制还是没意义。28法则，很多时候比如说，就是少数的几个订单表，写入了2000&#x2F;s，其他几十个表10&#x2F;s。</p>
<p>3、重写代码，写代码的同学，要慎重，当时我们其实短期是让那个同学重写了一下代码，插入数据之后，直接就更新，不要查询</p>
<p>4、如果确实是存在必须先插入，立马要求就查询到，然后立马就要反过来执行一些操作，对这个查询设置直连主库。不推荐这种方法，你这么搞导致读写分离的意义就丧失了</p>
<p> </p>
<h1 id="19、MySQL、Oracle、SqlServer区别"><a href="#19、MySQL、Oracle、SqlServer区别" class="headerlink" title="19、MySQL、Oracle、SqlServer区别"></a>19、MySQL、Oracle、SqlServer区别</h1><h3 id="1、灵活性"><a href="#1、灵活性" class="headerlink" title="1、灵活性"></a>1、灵活性</h3><p>MySQL对sql语句更灵活，比如：limit功能，insert可以一次插入多行数据，<br>select某些管理数据可以不加from；<br>oracle对sql语句的感觉更加稳重传统一些；</p>
<h3 id="2、保存数据的持久"><a href="#2、保存数据的持久" class="headerlink" title="2、保存数据的持久"></a>2、保存数据的持久</h3><p>MySQL是在数据库更新或者重启，则会丢失数据；<br>Oracle把提交的sql操作线写入了在线联机日志文件中，保持到了磁盘上，可以随时恢复；<br>SqlServer从2014之后，也拥有了完全持久和延迟持久特性；</p>
<h3 id="3、提交方式："><a href="#3、提交方式：" class="headerlink" title="3、提交方式："></a>3、提交方式：</h3><p>MySQL默认是自动提交（变量autocommit为ON）；<br>oracle默认不自动提交，需要用户手动提交（commit）；<br>SqlServer默认是自动提交，用户可手动停止（KILL）；</p>
<h3 id="4、语法差别"><a href="#4、语法差别" class="headerlink" title="4、语法差别"></a>4、语法差别</h3><p>排序问题。top , limit , rownum.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span> Server <span class="operator">/</span> MS Access 语法:</span><br><span class="line"><span class="keyword">SELECT</span> TOP number<span class="operator">|</span><span class="keyword">percent</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name;</span><br><span class="line"></span><br><span class="line">MySQL 语法:</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Persons</span><br><span class="line">LIMIT <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">Oracle 语法:</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Persons</span><br><span class="line"><span class="keyword">WHERE</span> ROWNUM <span class="operator">&lt;=</span><span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>还有时间函数。以及开窗函数的应用<br>MySQL是由瑞典MySQL AB公司开发，目前属于 Oracle 旗下产品；<br>Oracle是由美国ORACLE公司（甲骨文）开发的一组核心软件产品；<br>SqlServer是由Microsoft、Sybase和Ashton-Tate三家公司共同开发的，目前主属Microsoft；</p>
<p>MySQL优点：体积小、速度快、总体拥有成本低，开放源码<br>Oracle优点：使用方便、功能强大，可靠性好、安全性好、可移植性好、<br>适应高吞吐量，适用于各类大、中、小、微机环境。<br>SqlServer优点：图形化用户界面，丰富的编程接口工具，<br>与Windows NT完全集成，支持分布式的分区视图，适用于Win的Web技术的开发。</p>
<h1 id="20、索引"><a href="#20、索引" class="headerlink" title="20、索引"></a>20、索引</h1><h3 id="1、主键索引和辅助索引"><a href="#1、主键索引和辅助索引" class="headerlink" title="1、主键索引和辅助索引"></a>1、主键索引和辅助索引</h3><p><img src="/images/WEBRESOURCEfed00ea4267157a80d840bac50a5b5ac.png"></p>
<p><strong>innodb默认会建立主键索引</strong>，如果没有设置主键，<strong>也会增加一个隐藏的自增字段构建索引</strong>，而<strong>对于其他的索引来说都是辅助索引。</strong></p>
<p><img src="/images/WEBRESOURCEefc60192e8c6d020b99fd61f5d0456b7.png"></p>
<p><strong><font color="#dd0000">主键索引：存储索引和数据</font></strong></p>
<p><strong><font color="#dd0000">辅助索引：存储索引和主键值 </font></strong></p>
<h3 id="2、覆盖索引-避免回表"><a href="#2、覆盖索引-避免回表" class="headerlink" title="2、覆盖索引 避免回表"></a>2、覆盖索引 避免回表</h3><p><img src="/images/WEBRESOURCE6a863fc09db06931f7bb59281de5f725.png"></p>
<p>比如那么这一个索引，select * from t where name&#x3D;’xxx’ ，通过name索引拿到这个数据的主键，然后拿着主键的值去主键索引中查找到对应的数据，<strong>这个过程就是回表</strong>，</p>
<p>我们可以通过<strong>覆盖索引来避免回表</strong>，比如想通过name来查找身高，<strong>可以建立name和身高的联合索引</strong>，这样就能直接在联合索引中拿到身高的字段了，避免了回表</p>
<p><img src="/images/WEBRESOURCE2dab07bb8b41309024e1ed444a98b121.png"></p>
<h1 id="21、sql面试题"><a href="#21、sql面试题" class="headerlink" title="21、sql面试题"></a>21、sql面试题</h1><p>题目链接：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/b9068bfe5df74276bd015b9729eec4bf?tpId=82&tags=&title=&difficulty=0&judgeStatus=0&rp=1">https://www.nowcoder.com/practice/b9068bfe5df74276bd015b9729eec4bf?tpId=82&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1</a></p>
<p>分析：</p>
<p>这道题目考察的是SQL窗口函数（OLAP函数）中用于排序的专用窗口函数用法</p>
<p>下面介绍三种用于进行排序的专用窗口函数：</p>
<p>1、RANK()</p>
<p>在计算排序时，若存在相同位次，会跳过之后的位次。</p>
<p>例如，有3条排在第1位时，排序为：1，1，1，4······</p>
<p>2、DENSE_RANK()</p>
<p>这就是题目中所用到的函数，在计算排序时，若存在相同位次，不会跳过之后的位次。</p>
<p>例如，有3条排在第1位时，排序为：1，1，1，2······</p>
<p>3、ROW_NUMBER()</p>
<p>这个函数赋予唯一的连续位次。</p>
<p>例如，有3条排在第1位时，排序为：1，2，3，4······</p>
<p>窗口函数用法：</p>
<p>&lt;窗口函数&gt; OVER ( [PARTITION BY &lt;列清单&gt; ]</p>
<p>ORDER BY &lt;排序用列清单&gt; ）</p>
<p>*其中[ ]中的内容可以忽略</p>
<p>解答：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select emp_no, salary, dense_rank() over(order by salary desc) as t_rank</span><br><span class="line">from salaries</span><br><span class="line">order by t_rank asc, emp_no asc;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://issac2e.github.io">issac</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://issac2e.github.io/2022/12/06/mysql/mysql%E5%AD%97%E5%85%B8/">https://issac2e.github.io/2022/12/06/mysql/mysql%E5%AD%97%E5%85%B8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Mysql/">Mysql</a></div><div class="post_share"><div class="social-share" data-image="/./img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/01/16/JUC/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82JUC/" title="彻底搞懂JUC"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">彻底搞懂JUC</div></div></a></div><div class="next-post pull-right"><a href="/2022/10/16/java%E5%9F%BA%E7%A1%80/%E6%95%B4%E7%90%86%E4%B8%80%E4%B8%8Bdecimal/" title="decimal整理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">decimal整理</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">issac</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">16</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/issac2e"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/issac2e" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:issac2e@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">哈哈哈哈哈哈哈哈</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1%E3%80%81%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-text">1、执行过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%E5%9B%BE"><span class="toc-text">原理图</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2%E3%80%81redo-log%E3%80%81undo-log%E3%80%81binlog"><span class="toc-text">2、redo log、undo log、binlog</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E6%9D%A1SQL%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84"><span class="toc-text">一条SQL更新语句是如何执行的?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redo-log"><span class="toc-text">redo log</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undo-log"><span class="toc-text">undo log</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#binlog"><span class="toc-text">binlog</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E9%80%BB%E8%BE%91%E6%97%A5%E5%BF%97-binlog%E6%A0%BC%E5%BC%8F-show-variables-like-%E2%80%9C-binlog-format%E2%80%9D-%E9%BB%98%E8%AE%A4%E6%98%AFrow%E3%80%82"><span class="toc-text">1、逻辑日志 binlog格式:show variables like “%binlog_format” ,默认是row。</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E4%B8%BB%E4%BB%8E%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">如何解决主从不一致问题？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#RR-%E5%92%8C-RC-%E5%AF%B9%E6%AF%94"><span class="toc-text">RR 和 RC 对比</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E7%96%91%E9%97%AE"><span class="toc-text">两个疑问</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E6%9F%A5%E7%9C%8Bbinlog%E6%96%B9%E5%BC%8F"><span class="toc-text">2、查看binlog方式**</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E5%88%B7%E7%9B%98%E7%AD%96%E7%95%A5-sync-binlog"><span class="toc-text">3、刷盘策略:sync_binlog</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redo-log%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4"><span class="toc-text">redo log两阶段提交</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="toc-text">执行原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%9C%A8%E6%83%85%E5%86%B5"><span class="toc-text">存在情况</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%8E%9F%E7%90%86%E5%9B%BE"><span class="toc-text">更新数据原理图</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3%E3%80%81innodb-buffer%EF%BC%88TODO%EF%BC%89"><span class="toc-text">3、innodb buffer（TODO）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#innodb-buffer"><span class="toc-text">innodb buffer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#free%E9%93%BE%E8%A1%A8"><span class="toc-text">free链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#flush%E9%93%BE%E8%A1%A8"><span class="toc-text">flush链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lru%E9%93%BE%E8%A1%A8"><span class="toc-text">lru链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%A1%B5hash%E8%A1%A8"><span class="toc-text">缓存页hash表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B"><span class="toc-text">后台线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#innodb%E5%8F%82%E6%95%B0"><span class="toc-text">innodb参数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4%E3%80%81%E6%95%B0%E6%8D%AE%E9%A1%B5%E5%92%8C%E7%B4%A2%E5%BC%95%E9%A1%B5"><span class="toc-text">4、数据页和索引页</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E7%A9%BA%E9%97%B4"><span class="toc-text">表空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%A1%B5"><span class="toc-text">数据页</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%A1%8C%E5%AD%98%E5%82%A8%E7%A4%BA%E4%BE%8B"><span class="toc-text">数据行存储示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E7%B4%A2%E5%BC%95%E6%A8%A1%E5%9E%8B"><span class="toc-text">常见的索引模型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#hash%E7%B4%A2%E5%BC%95"><span class="toc-text">hash索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">二叉搜索树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E5%B9%B3%E8%A1%A1%E6%A0%91"><span class="toc-text">二叉平衡树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B%E6%A0%91"><span class="toc-text">B树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B-%E6%A0%91"><span class="toc-text">B+树</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E9%A1%B5"><span class="toc-text">索引页</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mysql%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B%E5%AF%B9%E5%BA%94%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="toc-text">mysql使用不同的索引类型对应的数据存储方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5%E3%80%81%E4%BA%8B%E5%8A%A1"><span class="toc-text">5、事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E7%89%A9ACID"><span class="toc-text">事物ACID</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E7%89%A9%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-text">事物隔离级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mvcc%E5%92%8Cread-view"><span class="toc-text">mvcc和read-view</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RC%E5%92%8CRR%E7%9A%84%E5%BF%AB%E7%85%A7%E8%AF%BB%E5%8C%BA%E5%88%AB"><span class="toc-text">RC和RR的快照读区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%92%8C%E6%98%AF%E5%90%A6%E8%87%AA%E5%8A%A8%E6%8F%90%E4%BA%A4"><span class="toc-text">隔离级别和是否自动提交</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6%E3%80%81%E9%94%81"><span class="toc-text">6、锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E9%94%81"><span class="toc-text">全局锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E9%94%81-TODO%E4%B8%8D%E8%AF%B4%E4%BA%BA%E8%AF%9D%E3%80%82%E3%80%82"><span class="toc-text">表锁(TODO不说人话。。)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C%E9%94%81"><span class="toc-text">行锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%B4%E7%95%8C%E9%94%81-%E5%AF%B9%E6%9F%90%E4%B8%AA%E5%8C%BA%E9%97%B4%E5%8C%85%E6%8B%AC%E6%9C%AC%E8%BA%AB%E5%8A%A0%E9%94%81%E5%8D%B3gap-record"><span class="toc-text">临界锁: 对某个区间包括本身加锁即gap+record</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%B4%E9%9A%99%E9%94%81-gap-lock-%E9%94%81%E5%AE%9A%E4%B8%80%E4%B8%AA%E8%8C%83%E5%9B%B4%E5%BD%93%E6%97%B6%E4%B8%8D%E5%8C%85%E6%8B%AC%E6%9C%AC%E8%BA%AB-%E9%97%B4%E9%9A%99%E9%94%81%E4%B9%8B%E5%89%8D%E4%B8%8D%E4%BA%92%E6%96%A5%E5%92%8C%E6%8F%92%E5%85%A5%E8%AF%A5%E9%97%B4%E9%9A%99%E7%9A%84sql%E4%BA%92%E6%96%A5"><span class="toc-text">间隙锁: gap-lock 锁定一个范围当时不包括本身,间隙锁之前不互斥和插入该间隙的sql互斥</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E9%94%81-record-lock-%E5%AF%B9%E6%9F%90%E4%B8%80%E8%A1%8C%E8%AE%B0%E5%BD%95%E5%8A%A0%E9%94%81"><span class="toc-text">记录锁 record-lock 对某一行记录加锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF-TODO"><span class="toc-text">锁分析思路 TODO</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7%E3%80%81JOIN"><span class="toc-text">7、JOIN</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Index-Nested-Loop-Join"><span class="toc-text">Index Nested-Loop Join</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Simple-Nested-Loop-join"><span class="toc-text">Simple Nested-Loop join</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Block-Nested-Loop-join"><span class="toc-text">Block Nested-Loop join</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MMR-%E4%BC%98%E5%8C%96"><span class="toc-text">MMR 优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Batched-Key-Access"><span class="toc-text">Batched Key Access</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BNL%E4%BC%98%E5%8C%96"><span class="toc-text">BNL优化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8%E3%80%81%E6%8E%92%E5%BA%8F"><span class="toc-text">8、排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%AD%97%E6%AE%B5%E6%8E%92%E5%BA%8F"><span class="toc-text">全字段排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rowid%E6%8E%92%E5%BA%8F"><span class="toc-text">rowid排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E6%8E%92%E5%BA%8F"><span class="toc-text">联合索引排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E6%8B%93%E5%B1%95"><span class="toc-text">联合索引拓展</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99"><span class="toc-text">联合索引最左匹配原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E8%A6%86%E7%9B%96"><span class="toc-text">索引覆盖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8"><span class="toc-text">索引下推</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#order-by%E6%88%96group-by%E4%B8%B4%E6%97%B6%E8%A1%A8"><span class="toc-text">order by或group by临时表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9%E3%80%81sql%E4%BC%98%E5%8C%96"><span class="toc-text">9、sql优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E7%B4%A2%E5%BC%95"><span class="toc-text">查看索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#explain"><span class="toc-text">explain</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E6%9C%AC%E5%88%86%E6%9E%90-%E8%AF%B4%E5%BE%97%E4%BB%80%E4%B9%88%E7%8E%A9%E6%84%8F%E3%80%82TODO"><span class="toc-text">成本分析 ????说得什么玩意。TODO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2"><span class="toc-text">回表查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E6%9F%A5%E8%AF%A2"><span class="toc-text">覆盖索引查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="toc-text">索引失效</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E4%B8%80-%E5%AD%90%E6%9F%A5%E8%AF%A2%E8%A2%AB%E4%BC%98%E5%8C%96%E4%B8%BAjoin"><span class="toc-text">案例一:子查询被优化为join</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E4%BA%8C-%E4%BC%98%E5%8C%96%E5%99%A8%E6%9C%AA%E9%80%89%E6%8B%A9%E7%B4%A2%E5%BC%95%E8%B5%B0%E5%85%A8%E8%A1%A8%E6%89%AB%E6%8F%8F"><span class="toc-text">案例二:优化器未选择索引走全表扫描</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E9%9D%9E%E5%94%AF%E4%B8%80%E9%94%81%E7%AD%89%E5%80%BC%E9%94%81"><span class="toc-text">2、非唯一锁等值锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E9%94%81"><span class="toc-text">3、主键索引范围锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E9%94%81"><span class="toc-text">4、非唯一索引范围锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E9%94%81bug"><span class="toc-text">5、唯一索引范围锁bug</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E4%B8%8A%E5%AD%98%E5%9C%A8%E7%9A%84%E7%AD%89%E5%80%BC"><span class="toc-text">6、非唯一索引上存在的等值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E3%80%81limit%E8%AF%AD%E5%8F%A5%E5%8A%A0%E9%94%81"><span class="toc-text">7、limit语句加锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8%E3%80%81%E6%AD%BB%E9%94%81%E7%9A%84%E6%A1%88%E4%BE%8B"><span class="toc-text">8、死锁的案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RC%E4%B8%8Bupdate-semi-consistent-read%E4%BC%98%E5%8C%96"><span class="toc-text">RC下update-semi-consistent read优化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12%E3%80%81%E6%AD%BB%E9%94%81"><span class="toc-text">12、死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C%E7%BA%A7%E9%94%81-for-update"><span class="toc-text">行级锁 for update</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%B4%E9%9A%99%E9%94%81%E6%89%A9%E5%BC%A0"><span class="toc-text">间隙锁扩张</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C%E9%94%81%E5%92%8C%E9%97%B4%E9%9A%99%E9%94%81"><span class="toc-text">行锁和间隙锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#show-engine-innodb-status"><span class="toc-text">show engine innodb status</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">死锁解决方案</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13%E3%80%81%E4%B8%BB%E5%A4%87"><span class="toc-text">13、主备</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E5%A4%87"><span class="toc-text">主备</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E5%A4%87%E5%8E%9F%E7%90%86"><span class="toc-text">主备原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#binlog%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">binlog三种方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8Cmaster"><span class="toc-text">双master</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%BB%B6%E6%97%B6%E6%83%85%E5%86%B5"><span class="toc-text">主从延时情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88"><span class="toc-text">同步方案</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14%E3%80%81%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE"><span class="toc-text">14、自增主键</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE"><span class="toc-text">自增主键</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%A2%9E%E9%94%81%E4%BC%98%E5%8C%96"><span class="toc-text">自增锁优化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#15%E3%80%81%E6%A1%88%E4%BE%8B"><span class="toc-text">15、案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#binlog%E5%A4%87%E4%BB%BD"><span class="toc-text">binlog备份</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%87%E5%BA%93%E5%A4%87%E4%BB%BD%E6%95%B0%E6%8D%AE%E4%B8%BB%E5%BA%93%E6%89%A7%E8%A1%8CDDL"><span class="toc-text">备库备份数据主库执行DDL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#delete%E6%95%B0%E6%8D%AE"><span class="toc-text">delete数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%8F1%E5%8F%96%E5%80%BC%E4%BC%98%E5%8C%96"><span class="toc-text">随1取值优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%AD%E8%BF%9E%E6%8E%A5%E9%A3%8E%E6%9A%B4"><span class="toc-text">短连接风暴</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#QPS%E7%AA%81%E5%A2%9E"><span class="toc-text">QPS突增</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D"><span class="toc-text">数据恢复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kill"><span class="toc-text">kill</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#16%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A7%84%E8%8C%83"><span class="toc-text">16、数据库规范</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%A7%84%E8%8C%83"><span class="toc-text">基本规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="toc-text">命名规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83"><span class="toc-text">表设计规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83"><span class="toc-text">列设计规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E8%A7%84%E8%8C%83"><span class="toc-text">索引规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sql%E8%A7%84%E8%8C%83"><span class="toc-text">sql规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5%E8%AE%BE%E8%AE%A1"><span class="toc-text">字段设计</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#17%E3%80%81%E5%B9%B6%E5%8F%91%E6%89%A3%E6%AC%BE"><span class="toc-text">17、并发扣款</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-text">如何保证数据一致性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89"><span class="toc-text">接口幂等</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis%E4%B8%AD%E4%BF%9D%E5%AD%98%E4%BD%99%E9%A2%9D"><span class="toc-text">redis中保存余额</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#18%E3%80%81%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8"><span class="toc-text">18、分库分表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8"><span class="toc-text">1、为什么要分库分表?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E7%94%A8%E8%BF%87%E5%93%AA%E4%BA%9B%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-text">2、用过哪些分库分表的中间件?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%BA%93%E7%9A%84%E6%8B%86%E5%88%86%E6%98%AF%E5%9E%82%E7%9B%B4%E8%BF%98%E6%98%AF%E6%B0%B4%E5%B9%B3-%E5%88%86%E5%BA%93%E8%BF%98%E6%98%AF%E5%88%86%E8%A1%A8"><span class="toc-text">3、库的拆分是垂直还是水平,分库还是分表?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%B0%86%E5%BD%93%E5%89%8D%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%8D%95%E5%BA%93%E5%8D%95%E8%A1%A8%E7%9A%84%E7%B3%BB%E7%BB%9F-%E6%9C%AA%E6%9D%A5%E8%BF%9B%E8%A1%8C%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8-%E5%A6%82%E4%BD%95%E5%88%87%E6%8D%A2"><span class="toc-text">4、将当前系统中单库单表的系统,未来进行分库分表,如何切换?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E5%AE%9E%E7%8E%B0%E3%80%81%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%EF%BC%9A"><span class="toc-text">5、分库分表实现、读写分离：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#19%E3%80%81MySQL%E3%80%81Oracle%E3%80%81SqlServer%E5%8C%BA%E5%88%AB"><span class="toc-text">19、MySQL、Oracle、SqlServer区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E7%81%B5%E6%B4%BB%E6%80%A7"><span class="toc-text">1、灵活性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E4%BF%9D%E5%AD%98%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8C%81%E4%B9%85"><span class="toc-text">2、保存数据的持久</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%8F%90%E4%BA%A4%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-text">3、提交方式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E8%AF%AD%E6%B3%95%E5%B7%AE%E5%88%AB"><span class="toc-text">4、语法差别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#20%E3%80%81%E7%B4%A2%E5%BC%95"><span class="toc-text">20、索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E5%92%8C%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95"><span class="toc-text">1、主键索引和辅助索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95-%E9%81%BF%E5%85%8D%E5%9B%9E%E8%A1%A8"><span class="toc-text">2、覆盖索引 避免回表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#21%E3%80%81sql%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">21、sql面试题</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/26/Redis/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%93%E5%AD%98%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%B8%80%E8%87%B4%E6%80%A7/" title="数据库缓存如何保证一致性">数据库缓存如何保证一致性</a><time datetime="2023-03-26T21:12:22.000Z" title="Created 2023-03-26 22:12:22">2023-03-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/17/UofG/itProject_Python/" title="itProject_Python">itProject_Python</a><time datetime="2023-03-17T22:02:08.000Z" title="Created 2023-03-17 22:02:08">2023-03-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/02/24/UofG/cardGame/" title="Card Game流程梳理">Card Game流程梳理</a><time datetime="2023-02-24T22:02:08.000Z" title="Created 2023-02-24 22:02:08">2023-02-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/02/14/UofG/Software%20Engineering/" title="Software Engineering">Software Engineering</a><time datetime="2023-02-14T22:02:08.000Z" title="Created 2023-02-14 22:02:08">2023-02-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/02/11/UofG/Advanced%20Programming/" title="Advanced Programming">Advanced Programming</a><time datetime="2023-02-11T22:02:08.000Z" title="Created 2023-02-11 22:02:08">2023-02-11</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By issac</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>